function gadget:GetInfo()
	return {
		name      = "Behavioural Profiling",
		desc      = "registers what states all Units/Projectiles are in and correlates them versus the framerate  ",
		author    = "Picasso",
		date      = "January, 2010",
		license   = "GNU GPL, v2 or later",
		layer     = 0,
		enabled   = false  --  loaded by default?
	}
end

----------------------------------------
----------------------------------------

-- synced only
if (not gadgetHandler:IsSyncedCode()) then

UnsyncedFrameStorage={}

function getPerformance(frameNr)
--TODO


end

AverageOver=90

function widget:frame(n)
PerfPerFrame=getPerformance()
local locTable=GG.StateToUnsyncedTable
	for frame,content in pairs(locTable) do
	ouncePerEntity=PerfPerFrame/content.entityCounter
	
				for state, nr in pairs (content.StateTable) do
				--we have now stored in every FrameTable a performancecost relative to the occurance
				content.StateTable[state]={val=nr*ouncePerEntity, nr=nr}	
				end
				
	--write back update
	UnsyncedFrameStorage[frame]=locTable
	end
	
	 
	if n % AverageOver and n> 1 then
		local TableOfPerfByStates=UnsyncedFrameStorage
		Global={}
			
			for i=#TableOfPerfByStates, #TableOfPerfByStates-AverageOver, -1 do
				for state,val in pairs(TableOfPerfByStates[i].StateTable) do
				if not Global[state] then Global[state]=0 end
				Global[state]=Global[state]+val
				end
			end
			--we need to factor in somehow that events affect only the performance in frames after them
			
			Spring.Echo("Always remember that  correlation does not imply causality! ")
			for k,v in pairs(Global) do
			Spring.Echo("State ".. k .. " with ".. v.nr .." Enitys  used an average of ".. (v.val/AverageOver) .. " in ".. AverageOver .." frames")
			end
						
				
				--we now have a rough grasp at the costs per event..	
	end
end
	
		


--widgetpart


else

local spGetUnitPosition=Spring.GetUnitPosition

AverageOver=75

MotherTable={}
--[frame].DebugTable
--[frame].frameRate
  
DebugTable={}
--[id].state.name
--[id].state.data

TableOfPerfByStates={}

GG.StateToUnsyncedTable={}

function gadget:GameFrame(n)
--we store the table
local DebugTableCopy=DebugTable
DebugTableCopy.PerfIndex=getPerformance(n)
GG.MotherTable[math.max(1,n-1)]=DebugTableCopy

	if n%15 == 0 and n> 0 then
	--correlate last 15 frames
	local Motherload=MotherTable
		for i=n, math.max(1,n-15), 1 do

		StateTable={}
		entityCounter=0
			for unitid, values in pairs(Motherload[i]) do
				
				if values.state then --we count for every unit which state she is in
					if StateTable[values.state] then StateTable[values.state]=StateTable[values.state]+1 else StateTable[values.state]=0 end
				entityCounter=entityCounter+1
				end
			
			end
		
		GG.StateToUnsyncedTable[i]={StateTable=StateTable, entityCounter=entityCounter}
		end
	end
end


function gadget:UnitCreated(unitID, unitDefID, unitTeam, builderID)
DebugTable[unitID]={typ="Unit",state="UnitCreated", data={unitID=unitID, unitDefID=unitDefID, unitTeam=unitTeam, builderID=builderID}}
end

    --Called at the moment the unit is created. 

function gadget:UnitFinished(unitID, unitDefID, unitTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={state="UnitFinished", data={unitID=unitID, unitDefID=unitDefID, unitTeam=unitTeam}, pos={x,y,z}}
   end

    --Called at the moment the unit is completed. 

function gadget:UnitFromFactory(unitID, unitDefID, unitTeam, factID, factDefID, userOrders)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={state="UnitFromFactory", data={unitID=unitID, unitDefID=unitDefID, unitTeam=unitTeam, factID=factID, factDefID=factDefID, userOrders=userOrders}, pos={x,y,z}}
end

    --Called when a factory finishes construction of a unit. 

function gadget:UnitGiven(unitID, unitDefID, newTeam, oldTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={state="UnitGiven", data={unitID=unitID, unitDefID=unitDefID,newTeam=newTeam, oldTeam=oldTeam}, pos={x,y,z}}
end

    --Called when a unit is transferred between teams. 

function gadget:UnitTaken(unitID, unitDefID, oldTeam, newTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={state="UnitTaken", data={unitID=unitID, unitDefID=unitDefID,newTeam=newTeam, oldTeam=oldTeam}, pos={x,y,z}}
   end

    --Called when a unit is transferred between teams. 

function gadget:UnitDamaged(unitID, unitDefID, unitTeam, damage, paralyzer, weaponDefID, projectileID, attackerID, attackerDefID, attackerTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={state="UnitDamaged", data={
unitID=unitID, 
 unitTeam= 			 unitTeam,
 damage= 			 damage,	
 paralyzer= 			 paralyzer,			
 weaponDefID= 			 weaponDefID,			
 projectileID= 			 projectileID,
 attackerID= 			 attackerID,	
 attackerDefID= 			 attackerDefID,			
 attackerTeamunit		=	 attackerTeamunit,
}, pos={x,y,z}}
   end

    --Called when a unit is damaged (after UnitPreDamaged). 

function gadget:UnitDestroyed(unitID, unitDefID, unitTeam, attackerID, attackerDefID, attackerTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitDestroyed", 
data={unitID=unitID, 
 unitTeam= 			 unitTeam,
 attackerID= 			 attackerID,	
 attackerDefID= 			 attackerDefID,			
 attackerTeam		=	 attackerTeam,
}, pos={x,y,z}}
   end

    --Called when a unit is destroyed. 

function gadget:UnitUnitCollision(colliderID, collideeID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitUnitCollision", 
data={
colliderID=colliderID, 
collideeID=collideeID
}, pos={x,y,z}}
   end

    --Called when two units collide. Both units must be registered with Script.SetWatchUnit. 

function gadget:UnitFeatureCollision(colliderID, collideeID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitUnitCollision", 
data={
colliderID=colliderID, 
collideeID=collideeID
}, pos={x,y,z}}
 end

    --Called when a unit collides with a feature. The unit must be registered with Script.SetWatchUnit and the feature registered with Script.SetWatchFeature. 

function gadget:UnitCommand(unitID, unitDefID, teamID, cmdID, cmdParams, cmdOptions)

   end

    --Called after when a unit accepts a command, after AllowCommand returns true. 

function gadget:UnitCmdDone(unitID, unitDefID, unitTeam, cmdID, cmdTag, cmdParams, cmdOpts)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitCmdDone", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

cmdID=cmdID,
 cmdTag= cmdTag, 
 cmdParams= cmdParams, 
 cmdOpts=cmdOpts
}, pos={x,y,z}}
   end

    --Called when a unit completes a command. 

function gadget:UnitLoaded(unitID, unitDefID, unitTeam, transportID, transportTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitLoaded", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

}, pos={x,y,z}}
 end

    --Called when a unit is loaded by a transport. 

function gadget:UnitUnloaded(unitID, unitDefID, unitTeam, transportID, transportTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitUnloaded", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

}, pos={x,y,z}}
   end

    --Called when a unit is unloaded by a transport. 

function gadget:UnitExperience(unitID, unitDefID, unitTeam, experience, oldExperience)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitExperience", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

}, pos={x,y,z}}
   end

    --Called when a unit gains experience greater or equal to the minimum limit set by calling Spring.SetExperienceGrade. 

function gadget:UnitIdle(unitID, unitDefID, unitTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitIdle", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

}, pos={x,y,z}}
   end

    --Called when a unit is idle (empty command queue). 

function gadget:UnitCloaked(unitID, unitDefID, unitTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitCloaked", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

}, pos={x,y,z}}
   end

    --Called when a unit cloaks. 

function gadget:UnitDecloaked(unitID, unitDefID, unitTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitDecloaked", 
data={
unitID=unitID, 
 unitTeam= 			 unitTeam,

}, pos={x,y,z}}
   end

    --Called when a unit decloaks. 

function gadget:UnitMoved(unitID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitMoved", 
data={
unitID=unitID, 


}, pos={x,y,z}}
   end

     -- Not implemented in base handler 

function gadget:UnitMoveFailed()
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitMoveFailed", 
data={
unitID=unitID, 
}, pos={x,y,z}}
   end

     -- Not implemented in base handler 

function gadget:StockpileChanged(unitID, unitDefID, unitTeam, weaponNum, oldCount, newCount)

   end

    --Called when a units stockpile of weapons increases or decreases. See stockpile. 

function gadget:UnitEnteredLos(unitID, unitTeam, allyTeam, unitDefID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitEnteredLos", 
data={
unitID=unitID, 
}, pos={x,y,z}}
   end

    --Called when a unit enters LOS of an allyteam. 

function gadget:UnitLeftLos(unitID, unitTeam, allyTeam, unitDefID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitLeftLos", 
data={
unitID=unitID, 
}, pos={x,y,z}}
   end

    --Called when a unit leaves LOS of an allyteam. 

function gadget:UnitEnteredRadar(unitID, unitTeam, allyTeam, unitDefID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitEnteredRadar", 
data={
unitID=unitID, 
}, pos={x,y,z}}
   end

    --Called when a unit enters radar of an allyteam. 

function gadget:UnitLeftRadar(unitID, unitTeam, allyTeam, unitDefID)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitLeftRadar", 
data={
unitID=unitID, 
}, pos={x,y,z}}
   end

    --Called when a unit leaves radar of an allyteam. 

function gadget:UnitEnteredAir()

   end

     -- Not implemented by base handler 

function gadget:UnitLeftAir()

   end

     -- Not implemented by base handler 

function gadget:UnitEnteredWater()

   end

     -- Not implemented by base handler 

function gadget:UnitLeftWater()

   end

     -- Not implemented by base handler 

function gadget:UnitSeismicPing(x, y, z, strength, allyTeam, unitID, unitDefID)

   end

    --Called when a unit emits a seismic ping. See seismicSignature. 


function gadget:FeatureCreated(featureID, allyTeamID)

DebugTable[featureID]={
state="FeatureCreated", 
data={
unitID=featureID, 
}}
   end

    --Called when a feature is created. 

function gadget:FeatureDamaged(featureID, featureDefID, featureTeam, damage, weaponDefID, projectileID, attackerID, attackerDefID, attackerTeam)
DebugTable[featureID]={
state="FeatureDamaged", 
data={
featureDefID, featureTeam, damage, weaponDefID, projectileID, attackerID, attackerDefID, attackerTeam=featureDefID, featureTeam, damage, weaponDefID, projectileID, attackerID, attackerDefID, attackerTeam
}}
   end

    --Called when a feature is damaged. 

function gadget:FeatureDestroyed(featureID, allyTeamID)

DebugTable[featureID]={
typ="Feature",
state="FeatureDestroyed", 
data={
unitID=featureID, 
}}
   end

    --Called when a feature is destroyed. 
function gadget:MoveCtrlNotify(unitID, unitDefID, unitTeam, data)
DebugTable[unitID]={
state="MoveCtrlNotify", 
data={
unitID=unitID, 
}}
end

function gadget:TerraformComplete(unitID, unitDefID, unitTeam, buildUnitID, buildUnitDefID, buildUnitTeam)
x,y,z=spGetUnitPosition(unitID)
DebugTable[unitID]={
state="UnitEnteredRadar", 
data={
unitID=unitID, 
}, pos={x,y,z}}

end


function gadget:FeatureMoved()
DebugTable[featureID]={
state="FeatureMoved", 
data={
unitID=featureID, 
}}
   end

     -- 

--Projectiles



function gadget:ProjectileCreated(proID, proOwnerID, weaponDefID)
DebugTable[proID]={
typ="Projectile",
state="ProjectileCreated", 
data={
unitID=proID, 
proOwnerID=proOwnerID, 
weaponDefID= weaponDefID
}}
   end

    --Called when the projectile is created. 

function gadget:ProjectileDestroyed(proID)
DebugTable[proID]={
typ="Projectile",
state="ProjectileDestroyed", 
data={
unitID=proID, 
proOwnerID=proOwnerID, 
weaponDefID= weaponDefID
}}
   end
   
end

    --Called when the projectile is destroyed. 