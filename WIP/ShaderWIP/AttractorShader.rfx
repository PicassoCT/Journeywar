<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE RENDER_MONKEY [
   <!ELEMENT RENDER_MONKEY
   (
      RmEffectWorkspace |
      RmRegistryBranch |
      RmClipboardNode
   )?>

   <!ELEMENT RmEffectWorkspace 
   (
      RmRegistryBranch?,
      RmPlugInData?,
      RmStringVariable*,
      (
         ( RmDirectXEffect, RmOpenGLEffect?, RmOpenGLESEffect? ) |
         ( RmOpenGLEffect, RmDirectXEffect?, RmOpenGLESEffect? ) |
         ( RmOpenGLESEffect, RmDirectXEffect?, RmOpenGLEffect? )
      )?,
      (
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmRenderableTexture |
         RmStreamMap |
         RmModelData |
         RmEffectGroup
      )*
   )>

   <!ELEMENT RmEffectGroup
   ( 
      RmPlugInData?,
      (
         RmStringVariable |
         RmDirectXEffect |
         RmOpenGLEffect |
         RmOpenGLESEffect |
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmRenderableTexture |
         RmStreamMap |
         RmModelData
      )*
   )>

   <!ELEMENT RmDirectXEffect
   ( 
      RmPlugInData?,
      (
         RmStringVariable |
         RmCamera |
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmRenderableTexture |
         RmStreamMap |
         RmModelData |
         RmPass
      )*
   )>

   <!ELEMENT RmOpenGLEffect
   (
      RmPlugInData?,
      (
         RmStringVariable |
         RmCamera |
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmRenderableTexture |
         RmStreamMap |
         RmModelData |
         RmGLPass
      )*
   )>
   
   <!ELEMENT RmOpenGLESEffect
   (
      RmPlugInData?,
      (
         RmStringVariable |
         RmCamera |
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmRenderableTexture |
         RmStreamMap |
         RmModelData |
         RmGLESPass
      )*
   )>

   <!ELEMENT RmPass
   ( 
      RmPlugInData?,
      RmStringVariable*,
      RmCameraReference?,
      RmModelReference?,
      RmRenderStateBlock?,
      (
         (
         ( RmHLSLShader | RmShader ),
         ( RmShader | RmHLSLShader )?
         )
      )?,
      RmRenderTarget*,
      RmTessellationNode?,
      RmStreamMapReference?,
      (
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmTextureObject |
         RmLightObject |
         RmMaterialObject
         )*
      )>
                                                                     
   <!ELEMENT RmGLPass
   ( 
      RmPlugInData?,
      RmStringVariable*,
      RmCameraReference?,
      RmModelReference?,
      RmRenderStateBlock?,
      (
         ( RmGLShader, RmGLShader? ) 
      )?,
      RmRenderTarget?,
      RmStreamMapReference?,
      (
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmTextureObject |
         RmLightObject |
         RmMaterialObject |
         RmShaderConstant |
         RmSampler
         )*
      )>

   <!ELEMENT RmGLESPass
   ( 
      RmPlugInData?,
      RmStringVariable*,
      RmCameraReference?,
      RmModelReference?,
      RmRenderStateBlock?,
      (
         ( RmGLESShader, RmGLESShader? ) 
      )?,
      RmRenderTarget?,
      RmStreamMapReference?,
      (
         RmBooleanVariable |
         RmIntegerVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmColorVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmTextureObject |
         RmLightObject |
         RmMaterialObject |
         RmShaderConstant |
         RmSampler
         )*
      )>      
      
   <!ELEMENT RmShader
   ( 
      RmShaderCode,
      RmPlugInData?,
      (
      RmStringVariable |
      RmShaderConstant
      )*
   )>

   <!ELEMENT RmHLSLShader
   ( 
      RmShaderCode,
      RmPlugInData?,
      (
      RmStringVariable |
      RmShaderConstant |
      RmSampler
      )*
   )>

   <!ELEMENT RmGLShader
   ( 
      RmShaderCode,
      RmPlugInData?,
      (
      RmStringVariable
      )*
   )>

   <!ELEMENT RmGLESShader
   ( 
      RmShaderCode,
      RmPlugInData?,
      (
      RmStringVariable
      )*
   )>
   
   <!ELEMENT RmTextureObject
   (
      RmPlugInData?,
      RmStringVariable*,
      RmTextureReference?,
      RmState*
   )>

   <!ELEMENT RmLightObject
   (
      RmPlugInData?,
      RmStringVariable*,
      RmLightReference?
   )>
   
   <!ELEMENT RmMaterialObject
   (
      RmPlugInData?,
      RmStringVariable*,
      RmMaterialReference?
   )>
   
   <!ELEMENT RmRenderStateBlock
   (
      RmPlugInData?,
      (
         RmStringVariable |
         RmState 
      )*
   )>

   <!ELEMENT RmTessellationNode
   (
      RmPlugInData?,
      RmStringVariable*
   )>
   
   <!ELEMENT RmStreamMap
   (
      RmPlugInData?,
      (
         RmStringVariable |
         RmStream 
      )*
   )>

   <!ELEMENT RmStream               ( RmPlugInData?, RmStreamChannel* )>

   <!ELEMENT RmModelData            ( RmPlugInData?, RmStringVariable* )>  
   <!ELEMENT RmTextureReference     ( RmPlugInData?, RmStringVariable* )>
   <!ELEMENT RmLightReference       ( RmPlugInData?, RmStringVariable* )>
   <!ELEMENT RmMaterialReference    ( RmPlugInData?, RmStringVariable* )>
   <!ELEMENT RmCameraReference      ( RmPlugInData?, RmStringVariable* )>
   <!ELEMENT RmModelReference       ( RmPlugInData?, RmStringVariable* )>
   <!ELEMENT RmStreamMapReference   ( RmPlugInData?, RmStringVariable* )>   
   <!ELEMENT RmRenderableTexture    ( RmPlugInData?, RmStringVariable* )>   
   <!ELEMENT RmRenderTarget         ( RmPlugInData?, RmStringVariable* )>   
   <!ELEMENT RmBooleanVariable      ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmFloatVariable        ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmVectorVariable       ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmMatrixVariable       ( RmPlugInData?, RmStringVariable? )>   
   <!ELEMENT RmColorVariable        ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmIntegerVariable      ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT Rm2DTextureVariable    ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmCubemapVariable      ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT Rm3DTextureVariable    ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmLightVariable        ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmMaterialVariable     ( RmPlugInData?, RmStringVariable? )>
   <!ELEMENT RmCamera               ( RmPlugInData?, RmStringVariable* )>

   <!ELEMENT RmStringVariable       ( RmTextDataBlock, RmPlugInData? )>
   
   <!ELEMENT RmDynamicVariable
   (
      RmDynamicVariableValueContainer,
      RmPlugInData?,
      RmStringVariable?
   )>
   
   <!ELEMENT RmDynamicVariableValueContainer
   (
      RmPlugInData?,
      RmDynamicVariableValue*
   )>
   
   <!ELEMENT RmTextDataBlock        ( #PCDATA ) >
   
   <!ELEMENT RmRegistryBranch
   ( 
      RmTextDataBlock?,
      (
         RmRegistryBranch |
         RmStringVariable |
         RmIntegerVariable |
         RmBooleanVariable |
         RmFloatVariable
      )*      
   )>

   <!ELEMENT RmPlugInData
   ( 
      RmTextDataBlock?,
      (
         RmStringVariable |
         RmIntegerVariable |
         RmBooleanVariable |
         RmFloatVariable |
         RmVectorVariable
      )*      
   )>
   
   <!ELEMENT RmClipboardNode
   (
      RmTextDataBlock?,
      (
         RmEffectWorkspace |
         RmEffectGroup |
         RmDirectXEffect |
         RmOpenGLEffect |
         RmOpenGLESEffect |
         RmPass |
         RmGLPass |
         RmGLESPass |
         RmShader |
         RmHLSLShader |
         RmGLShader |
         RmGLESShader |
         RmShaderConstant |
         RmSampler |
         RmTextureObject |
         RmLightObject |
         RmMaterialObject |
         RmRenderStateBlock |
         RmState |
         RmStreamMap |
         RmStream |
         RmStreamChannel |
         RmModelData |
         RmTextureReference |
         RmLightReference |
         RmMaterialReference |
         RmModelReference |
         RmStreamMapReference |
         RmRenderableTexture |
         RmRenderTarget |
         RmBooleanVariable |
         RmFloatVariable |
         RmVectorVariable |
         RmMatrixVariable |
         RmDynamicVariable |
         RmDynamicVariableValue |
         RmColorVariable |
         RmIntegerVariable |
         RmStringVariable |
         Rm2DTextureVariable |
         RmCubemapVariable |
         Rm3DTextureVariable |
         RmLightVariable |
         RmMaterialVariable |
         RmRegistryBranch |
         RmPlugInData |
         RmCamera |
         RmCameraReference
      )*      
   )>
   
   <!ELEMENT RmStreamChannel        ( RmPlugInData? ) >
   <!ELEMENT RmShaderConstant       ( RmPlugInData? ) >
   <!ELEMENT RmSampler              ( RmPlugInData? ) >
   <!ELEMENT RmState                ( RmPlugInData? ) >
   <!ELEMENT RmDynamicVariableValue ( RmPlugInData? ) >
   
   <!ELEMENT RmShaderCode           ( #PCDATA ) >

   <!ATTLIST RmEffectWorkspace 
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ACTIVE_EFFECT                 CDATA #REQUIRED
      VALIDATION_STRING             CDATA #REQUIRED
      XML_VERSION                   CDATA #REQUIRED
   >                                 

   <!ATTLIST RmEffectGroup           
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >                                 

   <!ATTLIST RmDirectXEffect                
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ACTIVE_CAMERA                 CDATA #REQUIRED
   >                                 

   <!ATTLIST RmOpenGLEffect                
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ACTIVE_CAMERA                 CDATA #REQUIRED
   >                                 
   
   <!ATTLIST RmOpenGLESEffect                
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ACTIVE_CAMERA                 CDATA #REQUIRED
   >                                 

   <!ATTLIST RmPass                  
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PASS_INDEX                    CDATA #REQUIRED
      ENABLED                       ( TRUE | FALSE ) #REQUIRED
   >                                 

   <!ATTLIST RmGLPass                  
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PASS_INDEX                    CDATA #REQUIRED
      ENABLED                       ( TRUE | FALSE ) #REQUIRED
   >                                 
   
   <!ATTLIST RmGLESPass                  
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PASS_INDEX                    CDATA #REQUIRED
      ENABLED                       ( TRUE | FALSE ) #REQUIRED
   >                                 
   
   <!ATTLIST RmShader        
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PIXEL_SHADER                  CDATA #REQUIRED
   >                                 

   <!ATTLIST RmHLSLShader        
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PIXEL_SHADER                  ( TRUE | FALSE ) #REQUIRED
      TARGET                        CDATA #REQUIRED
      ENTRY_POINT                   CDATA #REQUIRED
      COMPILER_FLAGS                CDATA #REQUIRED
   >  

   <!ATTLIST RmGLShader        
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PIXEL_SHADER                  ( TRUE | FALSE ) #REQUIRED
   >  
   
   <!ATTLIST RmGLESShader        
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PIXEL_SHADER                  ( TRUE | FALSE ) #REQUIRED
   >  

   <!ATTLIST RmShaderConstant
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      REGISTER                      CDATA #REQUIRED
   >                                 

   <!ATTLIST RmSampler               
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      REGISTER                      CDATA #REQUIRED
   >

   <!ATTLIST RmTextureObject
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      STATE_INDEX                   CDATA #REQUIRED
      VERTEX_TEXTURE                ( TRUE | FALSE ) #REQUIRED
   >

   <!ATTLIST RmLightObject
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      INDEX                         CDATA #REQUIRED
   >
   
   <!ATTLIST RmMaterialObject
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      INDEX                         CDATA #REQUIRED
   >
   
   <!ATTLIST RmRenderStateBlock
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >                                 

   <!ATTLIST RmState                 
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      STATE                         CDATA #REQUIRED
      VALUE                         CDATA #REQUIRED
      USAGE                         CDATA #REQUIRED
   >                               

   <!ATTLIST RmStreamMap           
     NAME                           CDATA #REQUIRED
     API                            CDATA #REQUIRED
   >                               

   <!ATTLIST RmStream              
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      STRIDE                        CDATA #REQUIRED
   >

   <!ATTLIST RmStreamChannel
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      DATA_SIZE                     CDATA #REQUIRED
      DATA_TYPE                     CDATA #REQUIRED
      REGISTER                      CDATA #REQUIRED
      USAGE                         CDATA #REQUIRED
      USAGE_INDEX                   CDATA #REQUIRED
      ATTRIBUTE_NAME                CDATA #REQUIRED
   >

   <!ATTLIST RmModelData
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      FILE_NAME                     CDATA #REQUIRED
      ORIENTATION                   CDATA #REQUIRED
   >

   <!ATTLIST RmTextureReference
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >

   <!ATTLIST RmLightReference
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >
   
   <!ATTLIST RmMaterialReference
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >
   
   <!ATTLIST RmModelReference
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >

   <!ATTLIST RmStreamMapReference
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
   >

   <!ATTLIST RmRenderableTexture
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      FILE_NAME                     CDATA #REQUIRED
      ORIGIN                        CDATA #REQUIRED
      WIDTH                         CDATA #REQUIRED
      HEIGHT                        CDATA #REQUIRED
      FORMAT                        CDATA #REQUIRED
      USE_VIEWPORT_DIMENSIONS       ( TRUE | FALSE ) #REQUIRED
      GENERATE_MIPMAPS              ( TRUE | FALSE ) #REQUIRED
      WIDTH_RATIO                   CDATA #REQUIRED
      HEIGHT_RATIO                  CDATA #REQUIRED
   >

   <!ATTLIST RmRenderTarget
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      INDEX                         CDATA #REQUIRED
      RENDER_TO_SCREEN              ( TRUE | FALSE ) #REQUIRED
      COLOR_CLEAR                   ( TRUE | FALSE ) #REQUIRED
      DEPTH_CLEAR                   ( TRUE | FALSE ) #REQUIRED
      CLEAR_COLOR_VALUE             CDATA #REQUIRED
      DEPTH_CLEAR_VALUE             CDATA #REQUIRED
   >
   
   <!ATTLIST RmBooleanVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VALUE                         CDATA #REQUIRED
   >

   <!ATTLIST RmFloatVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VALUE                         CDATA #REQUIRED
      MIN                           CDATA #REQUIRED
      MAX                           CDATA #REQUIRED
      CLAMP                         ( TRUE | FALSE ) #REQUIRED
   >

   <!ATTLIST RmVectorVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VALUE_0                       CDATA #REQUIRED
      VALUE_1                       CDATA #REQUIRED
      VALUE_2                       CDATA #REQUIRED
      VALUE_3                       CDATA #REQUIRED
      MIN                           CDATA #REQUIRED
      MAX                           CDATA #REQUIRED
      CLAMP                         ( TRUE | FALSE ) #REQUIRED
      NORMALIZE                     ( TRUE | FALSE ) #REQUIRED
   >

   <!ATTLIST RmMatrixVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VALUE_0                       CDATA #REQUIRED
      VALUE_1                       CDATA #REQUIRED
      VALUE_2                       CDATA #REQUIRED
      VALUE_3                       CDATA #REQUIRED
      VALUE_4                       CDATA #REQUIRED
      VALUE_5                       CDATA #REQUIRED
      VALUE_6                       CDATA #REQUIRED
      VALUE_7                       CDATA #REQUIRED
      VALUE_8                       CDATA #REQUIRED
      VALUE_9                       CDATA #REQUIRED
      VALUE_10                      CDATA #REQUIRED
      VALUE_11                      CDATA #REQUIRED
      VALUE_12                      CDATA #REQUIRED
      VALUE_13                      CDATA #REQUIRED
      VALUE_14                      CDATA #REQUIRED
      VALUE_15                      CDATA #REQUIRED
   >

   <!ATTLIST RmDynamicVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VARIABLE_TYPE                 ( FLOAT | INTEGER | BOOLEAN ) #REQUIRED
      ROWS                          CDATA #REQUIRED
      COLUMNS                       CDATA #REQUIRED
      FIXED_SIZE                    ( TRUE | FALSE ) #REQUIRED
      MIN                           CDATA #REQUIRED
      MAX                           CDATA #REQUIRED
      CLAMP                         ( TRUE | FALSE ) #REQUIRED
      NORMALIZE                     ( TRUE | FALSE ) #REQUIRED
   >
   
   <!ATTLIST RmDynamicVariableValue
      ROW_INDEX                     CDATA #REQUIRED
      COLUMN_INDEX                  CDATA #REQUIRED
      VALUE                         CDATA #REQUIRED
   >
   
   <!ATTLIST RmColorVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VALUE_0                       CDATA #REQUIRED
      VALUE_1                       CDATA #REQUIRED
      VALUE_2                       CDATA #REQUIRED
      VALUE_3                       CDATA #REQUIRED
   >

   <!ATTLIST RmIntegerVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      VALUE                         CDATA #REQUIRED
      MIN                           CDATA #REQUIRED
      MAX                           CDATA #REQUIRED
      CLAMP                         ( TRUE | FALSE ) #REQUIRED
   >
   
   <!ATTLIST RmStringVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
   >

   <!ATTLIST Rm2DTextureVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      FILE_NAME                     CDATA #REQUIRED
      ORIGIN                        CDATA #REQUIRED
   >

   <!ATTLIST RmCubemapVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      FILE_NAME                     CDATA #REQUIRED
      ORIGIN                        CDATA #REQUIRED
   >

   <!ATTLIST Rm3DTextureVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      FILE_NAME                     CDATA #REQUIRED
      ORIGIN                        CDATA #REQUIRED
   >

   <!ATTLIST RmLightVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      LIGHT_ENABLED                 ( TRUE | FALSE ) #REQUIRED
      LIGHT_TYPE                    ( POSITIONAL | DIRECTIONAL | SPOTLIGHT ) #REQUIRED
      AMBIENT_0                     CDATA #REQUIRED
      AMBIENT_1                     CDATA #REQUIRED
      AMBIENT_2                     CDATA #REQUIRED
      AMBIENT_3                     CDATA #REQUIRED
      DIFFUSE_0                     CDATA #REQUIRED
      DIFFUSE_1                     CDATA #REQUIRED
      DIFFUSE_2                     CDATA #REQUIRED
      DIFFUSE_3                     CDATA #REQUIRED
      SPECULAR_0                    CDATA #REQUIRED
      SPECULAR_1                    CDATA #REQUIRED
      SPECULAR_2                    CDATA #REQUIRED
      SPECULAR_3                    CDATA #REQUIRED
      POSITION_0                    CDATA #REQUIRED
      POSITION_1                    CDATA #REQUIRED
      POSITION_2                    CDATA #REQUIRED
      DIRECTION_0                   CDATA #REQUIRED
      DIRECTION_1                   CDATA #REQUIRED
      DIRECTION_2                   CDATA #REQUIRED
      ATTENUATION_0                 CDATA #REQUIRED
      ATTENUATION_1                 CDATA #REQUIRED
      ATTENUATION_2                 CDATA #REQUIRED
      SPOTLIGHT_THETA               CDATA #REQUIRED
      SPOTLIGHT_PHI                 CDATA #REQUIRED
      RANGE                         CDATA #REQUIRED
      FALLOFF                       CDATA #REQUIRED
   >
   
   <!ATTLIST RmMaterialVariable
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      ARTIST_EDITABLE               ( TRUE | FALSE ) #REQUIRED
      VARIABLE_SEMANTIC             CDATA #REQUIRED
      AMBIENT_0                     CDATA #REQUIRED
      AMBIENT_1                     CDATA #REQUIRED
      AMBIENT_2                     CDATA #REQUIRED
      AMBIENT_3                     CDATA #REQUIRED
      DIFFUSE_0                     CDATA #REQUIRED
      DIFFUSE_1                     CDATA #REQUIRED
      DIFFUSE_2                     CDATA #REQUIRED
      DIFFUSE_3                     CDATA #REQUIRED
      SPECULAR_0                    CDATA #REQUIRED
      SPECULAR_1                    CDATA #REQUIRED
      SPECULAR_2                    CDATA #REQUIRED
      SPECULAR_3                    CDATA #REQUIRED
      EMISSIVE_0                    CDATA #REQUIRED
      EMISSIVE_1                    CDATA #REQUIRED
      EMISSIVE_2                    CDATA #REQUIRED
      EMISSIVE_3                    CDATA #REQUIRED
      SPECULAR_POWER                CDATA #REQUIRED
   >
      
   <!ATTLIST RmRegistryBranch
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      XML_VERSION                   CDATA #REQUIRED
   >
   
   <!ATTLIST RmPlugInData
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      PLUGIN_GUID                   CDATA #REQUIRED
   >

   <!ATTLIST RmClipboardNode
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      XML_VERSION                   CDATA #REQUIRED
   >
   
   <!ATTLIST RmCamera                
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      CAMERA_POSITION_X             CDATA #REQUIRED
      CAMERA_POSITION_Y             CDATA #REQUIRED
      CAMERA_POSITION_Z             CDATA #REQUIRED
      LOOK_AT_VECTOR_X              CDATA #REQUIRED
      LOOK_AT_VECTOR_Y              CDATA #REQUIRED
      LOOK_AT_VECTOR_Z              CDATA #REQUIRED
      UP_VECTOR_X                   CDATA #REQUIRED
      UP_VECTOR_Y                   CDATA #REQUIRED
      UP_VECTOR_Z                   CDATA #REQUIRED
      FOV                           CDATA #REQUIRED
      NEAR_CLIP_PLANE               CDATA #REQUIRED
      FAR_CLIP_PLANE                CDATA #REQUIRED
   >                                 

   <!ATTLIST RmCameraReference                
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      USE_ACTIVE_CAMERA             ( TRUE | FALSE ) #REQUIRED
   >                               
   
   <!ATTLIST RmShaderCode                
      TYPE                          ( TEXT ) #REQUIRED
   >                               
   
   <!ATTLIST RmTextDataBlock                
      TYPE                          ( TEXT ) #REQUIRED
   >                               
   
   <!ATTLIST RmTessellationNode
      NAME                          CDATA #REQUIRED
      API                           CDATA #REQUIRED
      MIN_TESSELLATION_LEVEL        CDATA #REQUIRED
      MAX_TESSELLATION_LEVEL        CDATA #REQUIRED
   >
]>
<RENDER_MONKEY>
 <RmEffectWorkspace NAME="Effect Workspace" API="" ACTIVE_EFFECT="Effect Workspace.Effect Group 1.AttractorShader" VALIDATION_STRING="" XML_VERSION="RenderMonkey 1.71">
  <RmRegistryBranch NAME="RM_REGISTRY" API="" XML_VERSION="RenderMonkey 1.71">
   <RmRegistryBranch NAME="RM_LOCAL" API="" XML_VERSION="RenderMonkey 1.71">
    <RmRegistryBranch NAME="RM_PLUGIN" API="" XML_VERSION="RenderMonkey 1.71"><RmTextDataBlock TYPE="TEXT"><![CDATA[
<DockingPaneLayouts><Application_Layout><Pane-1><Type>0</Type><DockingCX>250</DockingCX><DockingCY>250</DockingCY><Title>Artist Editor</Title><ID>1001</ID><IconID>-1</IconID><Options>0</Options><DockingHolder>7</DockingHolder><FloatingHolder>0</FloatingHolder><LastHolder>7</LastHolder></Pane-1><Pane-2><Type>2</Type><DockingCX>0</DockingCX><DockingCY>0</DockingCY><Horiz>0</Horiz><Pane-1>3</Pane-1><Pane-2>8</Pane-2><Panes>2</Panes></Pane-2><Pane-3><Type>2</Type><DockingCX>0</DockingCX><DockingCY>398</DockingCY><Horiz>1</Horiz><Pane-1>4</Pane-1><Pane-2>6</Pane-2><Pane-3>7</Pane-3><Panes>3</Panes></Pane-3><Pane-4><Type>1</Type><DockingCX>250</DockingCX><DockingCY>250</DockingCY><Selected>5</Selected><Panes>1</Panes><Pane-1>5</Pane-1></Pane-4><Pane-5><Type>0</Type><DockingCX>250</DockingCX><DockingCY>250</DockingCY><Title>Workspace</Title><ID>1000</ID><IconID>-1</IconID><Options>0</Options><DockingHolder>4</DockingHolder><FloatingHolder>0</FloatingHolder><LastHolder>4</LastHolder></Pane-5><Pane-6><Type>4</Type><DockingCX>0</DockingCX><DockingCY>0</DockingCY></Pane-6><Pane-7><Type>1</Type><DockingCX>250</DockingCX><DockingCY>250</DockingCY><Selected>0</Selected><Panes>0</Panes></Pane-7><Pane-8><Type>1</Type><DockingCX>250</DockingCX><DockingCY>250</DockingCY><Selected>9</Selected><Panes>1</Panes><Pane-1>9</Pane-1></Pane-8><Pane-9><Type>0</Type><DockingCX>250</DockingCX><DockingCY>250</DockingCY><Title>Output</Title><ID>1002</ID><IconID>-1</IconID><Options>0</Options><DockingHolder>8</DockingHolder><FloatingHolder>0</FloatingHolder><LastHolder>8</LastHolder></Pane-9><Summary><TopContainer>2</TopContainer><Client>6</Client><Panes>9</Panes></Summary></Application_Layout></DockingPaneLayouts>
]]></RmTextDataBlock>
     <RmRegistryBranch NAME="RmPreviewDx9Window" API="" XML_VERSION="RenderMonkey 1.71"/>
     <RmRegistryBranch NAME="RmPreviewGLESWindow" API="" XML_VERSION="RenderMonkey 1.71"/>
     <RmRegistryBranch NAME="RmPreviewGLPreview" API="" XML_VERSION="RenderMonkey 1.71"/>
     <RmRegistryBranch NAME="RmLightEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="NoteEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmRenderableTextureEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmRenderTargetEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmRenderStateBlockEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmTextureObjectEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmTessellationNodeEditorDlg" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmTextureGenerator" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EditNodeRepository" API="" XML_VERSION="RenderMonkey 1.71"/>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmPreviewGLWindow" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="EffectPlacementRepository" API="" XML_VERSION="RenderMonkey 1.71">
       <RmRegistryBranch NAME="Effect Workspace.Effect Group 1.AttractorShader" API="" XML_VERSION="RenderMonkey 1.71">
        <RmIntegerVariable NAME="X" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="695" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="Y" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="59" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="Width" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="350" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="Height" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="350" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="ShowStatus" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="1" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="Visible" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="1" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="Minimized X" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="-1" MIN="-10" MAX="10" CLAMP="FALSE"/>
        <RmIntegerVariable NAME="Minimized Y" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="-1" MIN="-10" MAX="10" CLAMP="FALSE"/>
       </RmRegistryBranch>
      </RmRegistryBranch>
     </RmRegistryBranch>
     <RmRegistryBranch NAME="RmShaderEditor" API="" XML_VERSION="RenderMonkey 1.71">
      <RmRegistryBranch NAME="Effect Workspace.Effect Group 1.AttractorShader" API="" XML_VERSION="RenderMonkey 1.71">
       <RmRegistryBranch NAME="Disassembly" API="" XML_VERSION="RenderMonkey 1.71"/>
       <RmStringVariable NAME="Editing Shader" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC=""><RmTextDataBlock TYPE="TEXT"><![CDATA[
Fragment Program]]></RmTextDataBlock></RmStringVariable>
       <RmStringVariable NAME="Editing Pass" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC=""><RmTextDataBlock TYPE="TEXT"><![CDATA[
Pass 0]]></RmTextDataBlock></RmStringVariable>
       <RmIntegerVariable NAME="Y" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="0" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="Width" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="650" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="Height" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="597" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="ShowStatus" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="1" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="Visible" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="1" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="Minimized X" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="-1" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="Minimized Y" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="-1" MIN="-10" MAX="10" CLAMP="FALSE"/>
       <RmIntegerVariable NAME="X" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="" VALUE="0" MIN="-10" MAX="10" CLAMP="FALSE"/>
      </RmRegistryBranch>
     </RmRegistryBranch>
    </RmRegistryBranch>
    <RmRegistryBranch NAME="WORKSPACE" API="" XML_VERSION="RenderMonkey 1.71">
     <RmStringVariable NAME="LAST_SAVE" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC=""><RmTextDataBlock TYPE="TEXT"><![CDATA[
15/6/2017 19:13:37]]></RmTextDataBlock></RmStringVariable>
     <RmStringVariable NAME="VERSION" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC=""><RmTextDataBlock TYPE="TEXT"><![CDATA[
RenderMonkey Version 1.82 (build 322)]]></RmTextDataBlock></RmStringVariable>
     <RmStringVariable NAME="XML_VERSION" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC=""><RmTextDataBlock TYPE="TEXT"><![CDATA[
RenderMonkey 1.71]]></RmTextDataBlock></RmStringVariable>
     <RmStringVariable NAME="BASE_WORKSPACE_PATH" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC=""><RmTextDataBlock TYPE="TEXT"><![CDATA[
C:\Program Files (x86)\Spring\games\journeywar.sdd\WIP\ShaderWIP\]]></RmTextDataBlock></RmStringVariable>
    </RmRegistryBranch>
   </RmRegistryBranch>
  </RmRegistryBranch>
  <RmEffectGroup NAME="Effect Group 1" API="">
   <RmOpenGLEffect NAME="AttractorShader" API="OpenGL" ACTIVE_CAMERA="">
    <RmFloatVariable NAME="ftime0_1" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="Time0_1" VALUE="0.000000" MIN="-1.000000" MAX="1.000000" CLAMP="FALSE"/>
    <RmFloatVariable NAME="ftime0_2PI" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="Time0_2PI" VALUE="0.000000" MIN="-1.000000" MAX="1.000000" CLAMP="FALSE"/>
    <RmMatrixVariable NAME="matView" API="" ARTIST_EDITABLE="FALSE" VARIABLE_SEMANTIC="View" VALUE_0="1.000000" VALUE_1="0.000000" VALUE_2="0.000000" VALUE_3="0.000000" VALUE_4="0.000000" VALUE_5="1.000000" VALUE_6="0.000000" VALUE_7="0.000000" VALUE_8="0.000000" VALUE_9="0.000000" VALUE_10="1.000000" VALUE_11="0.000000" VALUE_12="0.000000" VALUE_13="0.000000" VALUE_14="0.000000" VALUE_15="1.000000"/>
    <RmStreamMap NAME="Stream Mapping" API="">
     <RmStream NAME="Stream" API="" STRIDE="32">
      <RmStreamChannel NAME="Position_0" API="" DATA_SIZE="12" DATA_TYPE="2" REGISTER="0" USAGE="0" USAGE_INDEX="0" ATTRIBUTE_NAME="rm_Vertex"/>
      <RmStreamChannel NAME="Normal_0" API="" DATA_SIZE="12" DATA_TYPE="2" REGISTER="0" USAGE="3" USAGE_INDEX="0" ATTRIBUTE_NAME="rm_Normal"/>
      <RmStreamChannel NAME="TexCoord_0" API="" DATA_SIZE="8" DATA_TYPE="1" REGISTER="0" USAGE="5" USAGE_INDEX="0" ATTRIBUTE_NAME="rm_TexCoord0"/>
     </RmStream>
    </RmStreamMap>
    <RmModelData NAME="Model" API="" FILE_NAME="..\..\..\..\..\AMD\RenderMonkey 1.82\Examples\Media\Models\Sphere.3ds" ORIENTATION="0"/>
    <RmGLPass NAME="Pass 0" API="OpenGL" PASS_INDEX="0" ENABLED="TRUE">
     <RmModelReference NAME="Model" API=""/>
     <RmGLShader NAME="Vertex Program" API="OpenGL" PIXEL_SHADER="FALSE"><RmShaderCode TYPE="TEXT"><![CDATA[
varying vec2 Position;
varying vec3 fNormal;
uniform mat4 modelViewMatrix;
varying float time0_1;


   varying float time0_2PI;
   varying vec4 vertexStartCol;
   varying vec4 vertexEndCol;
    vec3 Green =vec3(0.2,1.0,0.1);
    vec3 Blue =vec3(0.6,0.6,1.0);
    varying int vertexInSim = 0;
    varying float sinUs;  
 
 
    
#define PI 3.14159    

void main(void)
{
   
    gl_Position = gl_ModelViewProjectionMatrix *gl_Vertex;
    Position.x = 0.5 * mix(gl_Vertex.x, gl_Vertex.y, abs(gl_Normal.x));
    Position.y = 0.5 * mix(gl_Vertex.z, gl_Vertex.y, abs(gl_Normal.z));
   vertexStartCol=vec4(Green,0.9);
   vertexEndCol=vec4(Blue,0.3);
   sinUs=sin(((time0_2PI- PI)/300.0));
   sinUs=1.0;
  //  Position=f4Position.xy;
    fNormal= gl_Normal;
   
   
}]]></RmShaderCode></RmGLShader>
     <RmGLShader NAME="Fragment Program" API="OpenGL" PIXEL_SHADER="TRUE"><RmShaderCode TYPE="TEXT"><![CDATA[


   uniform float time0_1;
   uniform float time0_2PI;
   varying vec2 Position;
   varying vec3 fNormal;
   //Color at Vertex Start

   varying float sinUs;
   
    vec4 Black =vec4(0.0,0.0,0.0,0.0);
    vec4 Green =vec4(0.0,1.0,0.0,1.0);
    vec4 Blue =vec4(0.0,0.0,1.0,1.0);
    vec4 Yellow =vec4(0.0,0.1,1.0,1.0);
    vec4 Red =vec4(1.0,0.0,0.0,1.0);
    vec4 White =vec4(1.0,1.0,1.0,1.0);
    vec4 Grey =vec4(0.5,0.5,0.5,1.0);
    
    vec3 X_Axis = vec3(1.0,0,0);
    vec3 Y_Axis = vec3(0,1.0,0);
    vec3 Z_Axis = vec3(0,0,1.0);
    
    varying vec4 vertexStartCol;
    varying vec4 vertexEndCol;
   
   #define INTERPOLATION_STEPS 1
   #define MAX_RANGE_PARTICLES 15.0
   //Constants
   #define PI 3.14159
   #define PI2 (PI*2.0)
   #define INT_MAX ((!0)-1)
   #define INT_MIN (!0)
   
   
   float min(float x, float y) {
      if (x < y) return x;
      return y;
   }

   //hc = 2路sqrt(s路(s - a)路(s - b)路(s - c))/c
   // #define POSPROPORTION(DISTPOSUP,DISTPOSDOWN,DISTUPDOWN,RESULT) RESULT=(((DISTPOSUP)+(DISTPOSDOWN)+(DISTUPDOWN))*0.5);RESULT=((2.0*sqrt((RESULT)*((RESULT)-(DISTPOSUP))*((RESULT)-(DISTPOSDOWN))*((RESULT)-(DISTUPDOWN))))/(DISTUPDOWN));RESULT=((RESULT)*(RESULT)+(DISTPOSUP)*(DISTPOSUP));RESULT=(sqrt((RESULT))/(DISTUPDOWN));
   float posProportion( vec2 pPixel, vec2 pointA, vec2 pointB) {

   vec2 posIntersect;

   float m_X =       pointA.x -pointB.x;
   float m_Y =    pointA.y -pointB.y;
   float m_AB =   m_X/m_Y;
   float m_Intercept =  -1.0 * (m_Y/m_X);

   //computatet the steigung of the intercept
   //yi = m_Intercept * xi +t_intercept;
   //t_intercept = yi - m_Intercept *xi;
   float t_intercept = pPixel.y - m_Intercept *pPixel.x;
   float t_ab = pointA.y - (-1* m_Intercept) * pointA.x;

   //yi = m_Intercept * xi +t_intercept;
   //yab = m_ab * xab +t_ab;

   //we need the intersectionpoint
    posIntersect.x      = ( t_intercept - t_ab) /( m_AB -  m_Intercept);
    posIntersect.y    = m_Intercept *   (posIntersect.x + t_intercept);

   return distance(pointA, posIntersect)/distance(pointA,pointB);
   }

   
   //debugInfo
   #define isParticleNearPosition(PARTICLE,POSITION,TOLERANCE)  (distance(PARTICLE + Center.Pos,POSITION) < TOLERANCE) 
   //Helper functions
   #define RAND(X,Y)  (fract(sin(dot(X + Y ,vec2(12.9898,78.233)))*43758.5453))
   #define MATH_MAX(A,B)  = (A > B)? A: B;
   //Describes a linear Colour Gradient 
   struct colSampler{
   vec4 colIn;
   vec4 colOut;   
   };

   //Works as a mask, allowing to precomp, wether a rotation is needed
   struct borderLine{
      vec2 StartUp;
      vec2 EndUp;
      vec2 StartLow;
      vec2 EndLow;   
   };
   //Describes a linewise mask, pixelstart and pixelend
   struct mask{
      int start;
      int end;   
   };
   //1byte mask
   mask maskStartEnd;

   struct PointPair{
   vec2 Up;
   vec2 Low;
   };

   //Center of the Pseudo-LorenzSim Physics
   struct Attractor{
      vec2 Pos;
      vec2 dir;
      float linGravity;
      float expGravity;
      float PulseStrenghtTimeRatio;   
   //describes how much each pieces NewDir is affected by linGravity over time
      float sinusFactor;
      float maxDistanceParticles;
   };

   Attractor Center;

   //Particle bound to a attractor
   struct Particle{
      float rotationInAngleStep;
   //Positions are relative Positions to CenterPos
      vec2 Pos;
   //Directions are non-nomralized Vectors, containing as Sqrt(Vec) the force
      vec2 dir;   
      vec2 lastPos;
      vec2  lastDir;
      float MaxDistToPredecessor;
   };
   
   #define ADD_PATHPOINT(NR,PX,PY) CenterPath[NR]= vec2(PX,PY); 

   //Configuration
   #define CenterPathSize 2
   vec2 CenterPath[CenterPathSize];


   #define PARTICLESSIZE 5
   Particle Particles[PARTICLESSIZE];
   
   #define PERCENTAGE (1.0/ float(PARTICLESSIZE))
   
   #define GRADIENT_SIZE 9   
   float Gradient[GRADIENT_SIZE];
    
   #define ParticleConstructor(NR, DEG, POSX, POSY, DIRX, DIRY, MAXDIST)    Particles[NR].rotationInAngleStep= DEG;Particles[NR].Pos= vec2(POSX,POSY);Particles[NR].dir= vec2(DIRX,DIRY);Particles[NR].lastPos= vec2(POSX,POSY); Particles[NR].lastDir= vec2(DIRX,DIRY);Particles[NR].MaxDistToPredecessor= -1.0;
      //Defining the Colours the Gradient traverses from Start to End - Outermost color Gradient
      colSampler GradStartCol;
      colSampler GradEndCol;
     
   void init()
   {
   int i;
   //PathPoints
   ADD_PATHPOINT( 0, 1.0,0.0)        
   ADD_PATHPOINT( 1, -10.0,-5.0)            
   //ADD_PATHPOINT( 2, -10.0,-10.0)            
   //ADD_PATHPOINT( 3, 0,-20.0)                
   //ADD_PATHPOINT( 4,-5.0,4.0)         
   //ADD_PATHPOINT( 5,-4.0,5.0)         
   //ADD_PATHPOINT( 6,-3.0,6.0)         
   //ADD_PATHPOINT( 7,-2.0,7.0)
ParticleConstructor(0, PI* 0.3,1.0 ,1.1,0.1,0.1,20.0);     
ParticleConstructor(1, PI* 0.3,2.0 ,1.1,0.3,0.1,20.0);    
ParticleConstructor(2, PI* 0.3,4.0 ,1.1,0.3,0.1,20.0);     
ParticleConstructor(3, PI* 0.3,8.0 ,1.1,0.3,0.1,20.0);     
ParticleConstructor(4, PI* 0.3,12.0 ,1.1,0.3,0.1,20.0);     
   //StartPositionsParticle
   //ParticleConstructor(0, PI* time0_1,1.0 ,1.1,0.1,0.1,20.0);
   //ParticleConstructor(1, PI* time0_1,2.0 ,1.1,0.3,0.1,20.0);
   //ParticleConstructor(2, PI* time0_1,4.0 ,1.1,0.3,0.1,20.0);
   //ParticleConstructor(3, PI* time0_1,8.0 ,1.1,0.3,0.1,20.0);
   //ParticleConstructor(4, PI* time0_1,12.0 ,1.1,0.3,0.1,20.0);
   //ParticleConstructor(2, 4.0, 5.0,-1.0,0.1,0.1,2.0);

   //Initializing the Center 
   Center.Pos= vec2(0.0,0.0); 
   Center.dir= vec2(0.0,0.0);
   Center.linGravity=0.0; 
   Center.expGravity= 0.0;
   Center.PulseStrenghtTimeRatio=0.0;
   Center.sinusFactor=0.0;
   Center.maxDistanceParticles=MAX_RANGE_PARTICLES;
   
   //Colours and Gradient
      Gradient[0]=0.0;
      Gradient[1]=0.3 *sinUs;
      Gradient[2]=0.05*sinUs;
      Gradient[3]=0.7*sinUs;
      Gradient[4]=0.2*sinUs;
      Gradient[5]=1.0*sinUs;
      Gradient[6]=0.2*sinUs;
      Gradient[7]=0.3*sinUs;
      Gradient[8]=0.0; 
  

   }

   //Is the Pixel in Question in the physic sim
   bool isPixelInSim(int steps, vec2 Pos)
   {
   return  (distance(CenterPath[steps],Pos) < Center.maxDistanceParticles);
   }


   mat2 rotationMatrix(float angle)
   {
   return mat2( cos(angle), sin(angle),
         -1.0*sin(angle), cos (angle)); 
   }

   //sums up the component of a vector   
   float sum(vec3 element)
   {return element.x+element.y+element.z;}
   float sumv2(vec2 element)
   {return element.x+element.y;}   

   float interpolate(vec2 posA, vec2 posB, float Max)
   {   //Currently fades exponential to the midst Oo-.. ..-oO*1/MoveMentSpeedParticle 
      vec2 Mid=((posA + posB)*0.5);
      float DisTance;
      if( distance(posA,Mid) < distance(posB, Mid))
      DisTance= distance(posA, Mid);
      else
      DisTance= distance(posB, Mid);   
      
      return abs(min(DisTance/(Max*0.5), 1.0));
   }

   float alphaGradient(int index, float factor)
   {
   return   Gradient[index]*factor+ Gradient[min(GRADIENT_SIZE-1,index+1)]* (1.0-factor);      
   }
   



   bool PointInTriangle( vec2 a, vec2 b, vec2 c,vec2 s)
   {
      float as_x = s.x-a.x;
      float as_y = s.y-a.y;

      bool s_ab = (b.x-a.x)*as_y-(b.y-a.y)*as_x > 0.0;

      if((c.x-a.x)*as_y-(c.y-a.y)*as_x > 0.0 == s_ab) return false;

      if((c.x-b.x)*(s.y-b.y)-(c.y-b.y)*(s.x-b.x) > 0.0 != s_ab) return false;

      return true;
   }

   #define norm(v)     sqrt(dot(v,v))     // norm = length of  vector
   #define dist(u,v)      norm(u-v)          // distance = norm of difference
     // dist_Point_to_Segment(): get the distance of a point to a segment
   //     Input:  a Point P and a Segment S (in any dimension)
   //     Return: the shortest distance from P to S
   float minimum_distance(vec2 P0, vec2 P1, vec2 P)
   {
       vec2  v = P1 - P0;
       vec2  w = P - P0;

       float c1 = dot(w,v);
       if ( c1 <= 0 )
           return dist(P, P0);

       float c2 = dot(v,v);
       if ( c2 <= c1 )
           return dist(P, P1);


       vec2 Pb = P0 + (c1 / c2)*v;
       return dist(P, Pb);
   }



   //debugPrintBorders of Quads
   bool PointOnBorder(vec2 offSet, vec2 pNewOut, vec2 pNewIn, vec2 pOldOut, vec2 pOldIn, vec2 pPixel,float tol)
   {
   pNewOut+=offSet;
   pNewIn+=offSet;
   pOldOut+=offSet;
   pOldIn+=offSet;

   if (minimum_distance(pNewOut,pNewIn,pPixel) < tol) return true;
   if (minimum_distance(pNewIn,pOldIn,pPixel) < tol) return true;
   if (minimum_distance(pOldOut,pOldIn,pPixel) < tol) return true;
   if (minimum_distance(pOldOut,pNewOut,pPixel) < tol) return true;
   return false;
   }

   #define NORM(VAL_A,VAL_B) VAL_A = VAL_A/sqrt((VAL_A *VAL_A)+ (VAL_B*VAL_B)); VAL_B = 3* VAL_B/sqrt((VAL_A *VAL_A)+ (VAL_B*VAL_B));
   #define COMPOSE(COL,COLB, FACTOR) ((COL* FACTOR) +(COLB *(1.0 - FACTOR)))
   #define BLEND(COL_A,COL_B, START, END, RESULT_VARA, RESULT_VARB) RESULT_VARA= COL_A*START + COL_B *(1.0-START); RESULT_VARB= COL_A* END + COL_B(1.0- END);
   #define BLENDSAMPLER(COL_A,COL_B,COL_C,COL_D, PERCENT,   RESULT_VAR) RESULT_VAR.colIn= COL_A*PERCENT + COL_B *(1.0-PERCENT);RESULT_VAR.colOut= COL_C*PERCENT + COL_D *(1.0-PERCENT);
   
   //Draws Additive the polygons into the texture  
   //Particle Speed is factored in via the colSamplers
  vec4 AddDraw(colSampler qFrontCol,colSampler qRearCol, vec2 pNewOut, vec2 pNewIn, vec2 pOldOut, vec2 pOldIn, vec2 pPixel, int gradIndex)
   { 
   
    //check wether the Point is actually in the quad to prevent unnecessary work workload
   if (PointInTriangle(pNewOut, pNewIn, pOldOut, pPixel)==false && PointInTriangle(pNewIn,  pOldOut,pOldIn, pPixel)== false  ) return Black; 
      
   //TODO remove Debug
    if  (PointOnBorder( Center.Pos.xy,   pNewOut,  pNewIn,  pOldOut,  pOldIn,  pPixel,0.03)==true ) return Red;
       
        //Get pPixelition into Center Coordinate System Coords
     //   pPixel= pPixel - Center.Pos.xy; 


        
       float DistanceMidFrontRear, DistanceFrontPos;
       float totalDistanceRear, distancePosRearOut,distancePosRearIn, rearUpNormResult,rearDownNormResult;
       float totalDistanceFront, distancePosFrontOut,distancePosFrontIn, frontUpNormResult,frontDownNormResult;
       float distNormFrontRear;
       vec2  midPosFront, midPosRear;
       vec2  pMidInner, pMidOuter;
       vec2 pMidFront, pMidRear;
    
          //Rear    Side
        //total distance of the quads Rear In and Out Point
        totalDistanceRear= distance(pOldOut,pOldIn);      
        
      //distance of the Pixel Position to the rear Outward Point
        distancePosRearOut=distance(pPixel,pOldOut);
        
      //distance of the Position to the rear Inward Point
        distancePosRearIn=distance(pPixel,pOldIn);
        
        //computes the distance in percent up
      rearUpNormResult = posProportion( pPixel, pOldOut,  pOldIn);

      //POSPROPORTION(distancePosRearOut,distancePosRearIn,totalDistanceRear,rearUpNormResult);
        
      //computes the distance in percent down
        rearDownNormResult= 1.0 - rearUpNormResult;
        
      //estimate the midPos with the given percentage
       // midPosRear= COMPOSE(pOldIn,pOldOut,rearDownNormResult);
 
   //Front  Side
        //distance of the quads Front In and Out
         totalDistanceFront= distance(pNewOut,pNewIn);
        //distance of the Position to the front Outward Vertex
        distancePosFrontOut=distance(pPixel, pNewOut);
         //distance of the Position to the front Inward Vertex
        distancePosFrontIn=distance(pPixel,pNewIn);
        
        //computes the distance in percent down
      frontUpNormResult = posProportion( pPixel, pNewOut,  pNewIn);
      
      //computes the distance in percent up
        frontDownNormResult= abs( 1.0 - frontUpNormResult);
        //midPos
        //midPosFront= COMPOSE(pNewIn,pNewOut,frontUpNormResult);
   
   
    float    totalDistance_Inner, distancePosFrontIn_Inner, distancePosRearIn_Inner, FrontNormResult_Inner, RearNormResult_Inner  ;
    float    totalDistance_Outer, distancePosFrontOut_Outer, distancePosRearOut_Outer, Rear_NormResult_Outer, Front_NormResult_Outer  ;
   
   //Inner Side
        //distance of the quads Front In and Out
        totalDistance_Inner =    distance(pNewIn ,pOldIn); //distance
        //distance of the Position to the front Outward Vertex
        distancePosFrontIn_Inner  = distance(pPixel,  pNewIn); //distance
         //distance of the Position to the front Inward Vertex
        distancePosRearIn_Inner =distance(pPixel , pOldIn); //distance
        
        //computes the distance in percent down
         FrontNormResult_Inner = posProportion( pPixel, pNewIn,  pOldIn);
       
      //computes the distance in percent up
        RearNormResult_Inner = abs(1.0 - FrontNormResult_Inner);
      //midPos
        pMidInner= COMPOSE(pNewIn,pOldIn,FrontNormResult_Inner);
     //midPos
        pMidFront = COMPOSE(pNewIn,pNewOut,FrontNormResult_Inner);
   if (distance(pPixel,pMidInner) < 0.3 ) return Green;
     // if (distance(pPixel,pMidFront) < 0.3 ) return Yellow;
   
   //Outer Side
      //distance of the quads Front Out and Rear Out
        totalDistance_Outer = distance(pNewOut,pOldOut); //distance
        //distance of the Position to the front Outward Vertex
        distancePosFrontOut_Outer  = distance(pPixel, pNewOut); //distance
         //distance of the Position to the front Inward Vertex
        distancePosRearOut_Outer =distance(pPixel,pOldOut); //distance
        
        //computes the distance in percent down
       Rear_NormResult_Outer = posProportion( pPixel, pNewOut,  pOldOut);
           //computes the distance in percent up
        Front_NormResult_Outer = 1.0 - Rear_NormResult_Outer;
      //midPos
        pMidOuter= COMPOSE(pNewOut,pOldOut,Rear_NormResult_Outer);
      
      if (distance(pPixel,pMidOuter) < 0.3 ) return Green;
      

      
   float percentage_distDown    = distance(pMidOuter, pPixel)   ; //distance
   float percentage_distUp    = distance(pMidInner,pPixel)   ;//distance
   float dist_norm            = sqrt( percentage_distDown*percentage_distDown + percentage_distUp* percentage_distUp);
   
   //recombine the percentages of frontheight and rearheight
      percentage_distDown    =    abs(percentage_distDown /dist_norm);
      percentage_distUp      =    abs(percentage_distUp /dist_norm);
      
   //Lets compose the Color - Distortion Free
         
   //mix the lower color
   vec4 lowerCol = (qFrontCol.colIn * RearNormResult_Inner) + (qRearCol.colIn * (FrontNormResult_Inner));
   
   //mix the upper color
   vec4 upperCol = (qFrontCol.colOut * Front_NormResult_Outer) + (qRearCol.colOut * (Rear_NormResult_Outer) );
   

   
   
   //mix the lower and upper color
    vec4 resultCol= mix(lowerCol, upperCol, percentage_distDown);
   return resultCol; 
     
   //Front Alpha Gradient
      float FrontAlphaGradient=alphaGradient(gradIndex,frontDownNormResult);
   //Rear Alpha Gradient
      float RearAlphaGradient=alphaGradient(gradIndex,rearDownNormResult);
      
      //Lower one wins
      FrontAlphaGradient= min(FrontAlphaGradient,qFrontCol.colIn.a);
      RearAlphaGradient=  min (RearAlphaGradient,qRearCol.colIn.a);
      
      //Get a global Percentage
      float absoluteAlphaGradient=    COMPOSE(FrontAlphaGradient,RearAlphaGradient,distNormFrontRear);
      
     
      float distanceFrontMidPos_Pos= distance(midPosFront,pPixel);
      
      
 

      //  resultCol*=absoluteAlphaGradient;
      return resultCol;
     
   }

   //calculate a new attractor position
   vec2 newAttractorPosition(vec2 interValStart, vec2 interValEnd, float percentage, float time)
   {   
      vec2 midPoint= vec2(interValEnd*(1.0 -percentage)+ interValStart*percentage);
      
      return midPoint;
   }

   void updateParticlePosition( int p)
   {   
      float fRotationDynamicPart, fTotalRotation;
      mat2  rMat;
      //save the particles old Position
      Particles[p].lastPos=Particles[p].Pos;

      //calculte dynamic part of the Rotation
      fRotationDynamicPart=0.0;//atan(Particles[p].dir);
      fTotalRotation =  Particles[p].rotationInAngleStep + fRotationDynamicPart; // speed*atan(Particles[p].dir.x,Particles[p].dir.y);
      //fTotalRotation=sin(time0_1*PI2 -PI);
    
      rMat=rotationMatrix(fTotalRotation);
      
      Particles[p].Pos.xy =  rMat*Particles[p].Pos.xy;   
   }

   //Debug Displays the ParticlePoints and AttractorPoint
   bool atParticleStartPos(vec2 localPos, float tol)
   {
      bool match= false;
      for (int i= 0; i< PARTICLESSIZE;i++)
      {   
        if (distance(Particles[i].Pos.x,localPos.x) < tol && distance(Particles[i].Pos.y,localPos.y) < tol )
        {
          match=true;
        }      
      }   
      
        if (distance(Center.Pos.x,localPos.x) < tol && distance(Center.Pos.y, localPos.y) < tol )
        {
          match=true;
        }      
      
      return match;
   }

   float InterPolationSteps = 5.0;

   vec4 doPhySim(float percent, float time, vec2 Pos)
   {
      vec4 accumulatedColour= Black;
      float outerFactorDistance, innerFactorDistance;
      
      //DebugDelMe
        if (atParticleStartPos(Pos,0.1)== true) return Red;
      //DebugDelMe 
      
     //Move along the CenterPath in SimSteps   -> Steps of the same colourgradient can be parallized  
      //Cost Total:   (steps*(particles-1)) /ProcessingUnits
        for (int attrPath=0; attrPath< CenterPathSize-1;attrPath++)
        {
        //if this pixel is within range of a pathPoint+ maxRange
        if (!isPixelInSim(attrPath,Pos))continue;
        //StartColour of this Part of PathIntervall
        float startPercentage= min(float(attrPath),float(CenterPathSize))/float(CenterPathSize);
        //EndColour of this Part of PathIntervall
        float endPercentage= min(float(attrPath+1),float(CenterPathSize))/float(CenterPathSize);   
         //Set the Start End Colour of this PartPath
          GradEndCol.colOut=    vertexStartCol*startPercentage + vertexEndCol*(1.0 - startPercentage) ;      GradEndCol.colIn=   GradEndCol.colOut;
          GradStartCol.colOut  =   vertexStartCol*endPercentage   + vertexEndCol*(1.0 - endPercentage)  ;      GradStartCol.colIn =  GradStartCol.colOut ;
        
         for (int steps=0; steps < INTERPOLATION_STEPS ;steps++)
         {          
            
        //calculate the new AttractorPosition
        Center.Pos= newAttractorPosition(CenterPath[attrPath],CenterPath[attrPath+1],(0.1+float(steps))/InterPolationSteps,time);
         //Colorsampler containing the strips Front and Rear Color
       float StripFrontPercentage, StripRearPercentage,stripPercent;
       stripPercent= 1/INTERPOLATION_STEPS;
       
       StripFrontPercentage = min( stripPercent*(steps+1),1.0);
       StripRearPercentage =min( stripPercent*(steps),1.0);
    
       colSampler StripFront;
       colSampler StripRear;
          
        //mix this color for this interpolation step
    
      BLENDSAMPLER(GradStartCol.colIn, GradEndCol.colIn, GradEndCol.colOut, GradEndCol.colOut,StripFrontPercentage, StripFront)
      BLENDSAMPLER(GradStartCol.colIn, GradEndCol.colIn, GradEndCol.colOut, GradEndCol.colOut, StripRearPercentage, StripRear)

             //SetNewPosition
            for (int p=0;p < PARTICLESSIZE; p++)
            {  
   
      
               //calculate a new Position
               updateParticlePosition( p);
               
               //factor in the traversed Distance into the colour (this disregards the curve taken)   
               float OutTraversedDistance = distance(Particles[p].Pos,Particles[p].lastPos);
               float InnerTraversedDistance= distance(Particles[p-1].Pos,Particles[p-1].lastPos);
               float sumDistance= OutTraversedDistance + InnerTraversedDistance;
            
               //multiply by traversed distance
               outerFactorDistance=1.0-(OutTraversedDistance/sumDistance);
               innerFactorDistance=1.0-(InnerTraversedDistance/sumDistance);
        
  
              //Get the outer Percentage of the colorstrip
      
            colSampler RearCol;
         colSampler FrontCol;
         
             if (p > 0)
             {
         float index = float(p-1);
         if (index == 0) index = 1;

         
         RearCol.colIn =      (index * PERCENTAGE *StripRear.colIn )+  ((PARTICLESSIZE- index)*PERCENTAGE *StripRear.colOut); 
         RearCol.colOut =     ((p)*PERCENTAGE *StripRear.colIn)  +  ((PARTICLESSIZE-p)*PERCENTAGE *StripRear.colOut); 
         FrontCol.colIn =   ((index)*PERCENTAGE *StripFront.colIn)  +  ((PARTICLESSIZE- index)*PERCENTAGE *StripFront.colOut); 
         FrontCol.colOut =   ((p)*PERCENTAGE *StripFront.colIn)  +  ((PARTICLESSIZE-p)*PERCENTAGE *StripFront.colOut); 
         
      //TODO Delete Me
       RearCol.colIn  = Red;
       RearCol.colOut = Blue;
       
         FrontCol.colIn= Red;
         FrontCol.colOut = Blue;
      //TODO Delete Me 

       
             accumulatedColour = accumulatedColour +  AddDraw(FrontCol, RearCol, Particles[p].Pos, Particles[p-1].Pos, Particles[p].lastPos, Particles[p-1].lastPos, Pos, int( float(float(p)/float(PARTICLESSIZE)* GRADIENT_SIZE)));  
          
             } 
            }
         }
       }
   return accumulatedColour;
   }


   float totalTime=90.0;
   float colDecayTime=30.0;
   float globalPercentColDecay;


   void main(void)
   {

      //initialise Particles and Attractor 
      init();
      //SetToDefault
      gl_FragColor=Black;  
      
      //the percentAgeOfTheWay the projectile has travelled
      globalPercentColDecay = mod(time0_1/colDecayTime,1.0);
      bool  InPhySim=false;
      bool  ItterationTest=false;
      
      for (int i=0; i< CenterPathSize;i++)
      {
        ItterationTest= isPixelInSim(i,Position.xy);
        InPhySim = ( InPhySim || ItterationTest);
      
      }
     

      if (InPhySim==true) {
        gl_FragColor= doPhySim(mod(time0_1/totalTime,1.0), time0_1, Position.xy);
       
        }
      else 
      { 
      
        gl_FragColor= ((vec4(0.9,0.9,0.9,1.0) + gl_FragColor)/sum(1.0 - normalize(fNormal)));
      }   

   }


]]></RmShaderCode></RmGLShader>
     <RmStreamMapReference NAME="Stream Mapping" API=""/>
    </RmGLPass>
   </RmOpenGLEffect>
  </RmEffectGroup>
 </RmEffectWorkspace>
</RENDER_MONKEY>
