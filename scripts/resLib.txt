--RubbleScript
--This script spawns the rubbleHeap. If you too drunk to understad, just copy and paste into the Killed function
spx,spy,spz=Spring.GetUnitPosition(unitID)
teamID=Spring.GetUnitTeam(unitID)
x=math.random(0,3)
heapID=Spring.CreateUnit("gCScrapHeap",spx,spy,spz, x, teamID)
Spring.SetUnitNeutral(heapID,true)
--/RubbleScript





[16:37:50] <[LCC]Pako> gl.TexRect(x1,y1,x2,y2)
[16:41:20] <[LCC]Pako> to bind a texture: gl.Texture("LuaUI/Images/myTexture.png")
[16:41:37] <[LCC]Pako> and gl.Texture(false) to unbind


--[[
Lua unit script -> Gadget

Lua unit scripts run in the same Lua state as synced LuaRules (gadgets). In Lua unit scripts, the global table GG is also available. 
So anything can be triggered in a gadget if the gadget exposes a function in the GG table:

gadget

function GG.MyEvent(unitID, message)
  --Spring.Echo('unit ' .. unitID .. ' sent a message to the gadget: ' .. message)
end

Lua unit script

if someCondition then
  GG.MyEvent(unitID, 'hello, world!')
end

Gadget -> Lua unit script

A gadget can also invoke a function in a Lua unit script. The function Spring.UnitScript.GetScriptEnv(unitID) will return the
 environment table of a Lua unit script. That means, the table of per-unit global variables. So, a LUS can define a global function, 
 and then any gadget can find this function using GetScriptEnv and invoke it.

Here's an example:

Lua unit script

function MyEvent(message)
  --Spring.Echo('unit ' .. unitID .. ' received a message: ' .. message)
end

gadget

if someCondition then
  env = Spring.UnitScript.GetScriptEnv(unitID)
  env.MyEvent('dead or alive?')
end

Care must be taken however because the Lua unit script API is stateful (so that the unitID does not need to be passed to 
each and every animation functions). So if you want to use animation functions in the function MyEvent in the above example you need to 
use something slightly different in the gadget:

if someCondition then
  env = Spring.UnitScript.GetScriptEnv(unitID)
  Spring.UnitScript.CallAsUnit(unitID, env.MyEvent, 'dead or alive?')
end





]]

--[[Grass

Spring.GetGroundHeight

 ( number x, number z ) -> number y

Spring.GetGroundOrigHeight

 ( number x, number z ) -> number y





FIXME

Spring.RemoveGrass

 ( number x, number y, number z ) -> nil

Heightmap

Note that x & z coords are in worldspace (Game.mapSizeX/Z), still the heightmap resolution is Game.squareSize.

Spring.LevelHeightMap

 ( number x1, number z1 [, number x2, number z2], number height ) -> nil

Spring.AdjustHeightMap (heightmap[x][z] += height;)

 ( number x1, number z1 [, number x2, number z2], number height ) -> nil

Spring.RevertHeightMap

 ( number x1, number z1 [, number x2, number z2], number origFactor ) -> nil



Spring.SetHeightMapFunc

 ( lua_function [, arg1 ,[ arg2 [, ... ] ] ) -> nil | number absTotalHeightMapAmountChanged

Example code:

Spring.SetHeightMapFunc(function()
	for z=0,Game.mapSizeZ, Game.squareSize do
		for x=0,Game.mapSizeX, Game.squareSize do
			Spring.SetHeightMap( x, z, 200 + 20 * math.cos((x + z) / 90) )
		end
	end
end)

Spring.AddHeightMap can only be called in SetHeightMapFunc()

 ( number x, number z, number height ) -> nil | number newHeight

Spring.SetHeightMap can only be called in SetHeightMapFunc()

 ( number x, number z, number height [,number terraform = 1] ) -> nil | number absHeightDiff

the terraform argument is a scaling factor: so if 0 nothing will be changed (the terraform starts) and if it is 1 the terraform will be finished.

]]--





		--unitSpawnBuild
		local posX,  posY,  posZ=Spring.GetUnitPosition(unitID)
        	local unitTeam=Spring.GetUnitTeam(unitID)									
	        local u = Spring.CreateUnit ("cBuildCubeMed", posX,posY,posZ,0, unitTeam)



pillarX = {}

cPilarX = 	 	piece"cPilarX" 		table.insert(pillarX,cPilarX   )
cRstealthCX= 	piece"cRstealthCX" 	table.insert(pillarX, cRstealthCX  )
cPillarCroX= 	piece"cPillarCroX" 	table.insert(pillarX,cPillarCroX   )
cPilarMechX= 	piece"cPilarMechX" 	table.insert(pillarX, cPilarMechX  )
cRailWayX1 = 	piece"cRailWayX1" 	table.insert(pillarX, cRailWayX1  )
cRailFoldX1 = 	piece"cRailFoldX1" 	table.insert(pillarX,cRailFoldX1   )
cRailRX1 = 		piece"cRailRX1" 	table.insert(pillarX, cRailRX1  )
cRailLX1 = 		piece"cRailLX1" 	table.insert(pillarX,cRailLX1   )
cRailWayX2 = 	piece"cRailWayX2" 	table.insert(pillarX, cRailWayX2  )
cRailFoldX2 = 	piece"cRailFoldX2"	table.insert(pillarX, cRailFoldX2  )
cRailRX2 = 		piece"cRailRX2" 	table.insert(pillarX, cRailRX2  )
cRailLX2 = 		piece"cRailLX2" 	table.insert(pillarX,cRailLX2   )




GET TARGET_ID

SET [tag] 
Get [tag]


#define ACTIVATION 1 // set or get
#define STANDINGMOVEORDERS 2 // set or get
#define STANDINGFIREORDERS 3 // set or get
#define HEALTH 4 // get (0-100%)
#define INBUILDSTANCE 5 // set or get
#define BUSY 6 // set or get (used by misc. special case missions like transport ships)
#define PIECE_XZ 7 // get
#define PIECE_Y 8 // get
#define UNIT_XZ 9 // get
#define UNIT_Y 10 // get
#define UNIT_HEIGHT 11 // get
#define XZ_ATAN 12 // get atan of packed x,z coords
#define XZ_HYPOT 13 // get hypot of packed x,z coords
#define ATAN 14 // get ordinary two-parameter atan
#define HYPOT 15 // get ordinary two-parameter hypot
#define GROUND_HEIGHT 16 // get land height, 0 if below water
#define BUILD_PERCENT_LEFT 17 // get 0 = unit is built and ready, 1-100 = How much is left to build
#define YARD_OPEN 18 // set or get (change which plots we occupy when building opens and closes)
#define BUGGER_OFF 19 // set or get (ask other units to clear the area)
#define ARMORED 20 // set or get

/*#define WEAPON_AIM_ABORTED 21
#define WEAPON_READY 22
#define WEAPON_LAUNCH_NOW 23
#define FINISHED_DYING 26
#define ORIENTATION 27*/
#define IN_WATER 28
#define CURRENT_SPEED 29
//#define MAGIC_DEATH 31
#define VETERAN_LEVEL 32
#define ON_ROAD 34

#define MAX_ID 70
#define MY_ID 71
#define UNIT_TEAM 72
#define UNIT_BUILD_PERCENT_LEFT 73
#define UNIT_ALLIED 74
#define MAX_SPEED 75
#define CLOAKED 76
#define WANT_CLOAK 77
#define GROUND_WATER_HEIGHT 78 // get land height, negative if below water
#define UPRIGHT 79 // set or get
#define POW 80 // get
#define PRINT 81 // get, so multiple args can be passed
#define HEADING 82 // get
#define TARGET_ID 83 // get
#define LAST_ATTACKER_ID 84 // get
#define LOS_RADIUS 85 // set or get
#define AIR_LOS_RADIUS 86 // set or get
#define RADAR_RADIUS 87 // set or get
#define JAMMER_RADIUS 88 // set or get
#define SONAR_RADIUS 89 // set or get
#define SONAR_JAM_RADIUS 90 // set or get
#define SEISMIC_RADIUS 91 // set or get
#define DO_SEISMIC_PING 92 // get
#define CURRENT_FUEL 93 // set or get
#define TRANSPORT_ID 94 // get
#define SHIELD_POWER 95 // set or get
#define STEALTH 96 // set or get
#define CRASHING 97 // set or get, returns whether aircraft isCrashing state
#define CHANGE_TARGET 98 // set, the value it's set to determines the affected weapon
#define CEG_DAMAGE 99 // set
#define COB_ID 100 // get
#define PLAY_SOUND 101 // get, so multiple args can be passed
#define KILL_UNIT 102 // get KILL_UNIT(unitId, SelfDestruct=true, Reclaimed=false)
#define ALPHA_THRESHOLD 103 // set or get
#define SET_WEAPON_UNIT_TARGET 106 // get (fake set)
#define SET_WEAPON_GROUND_TARGET 107 // get (fake set)
#define SONAR_STEALTH 108 // set or get
#define REVERSING 109 // get

// NOTE: [LUA0 - LUA9] are defined in CobThread.cpp as [110 - 119]

#define FLANK_B_MODE 120 // set or get
#define FLANK_B_DIR 121 // set or get, set is through get for multiple args
#define FLANK_B_MOBILITY_ADD 122 // set or get
#define FLANK_B_MAX_DAMAGE 123 // set or get
#define FLANK_B_MIN_DAMAGE 124 // set or get
#define WEAPON_RELOADSTATE 125 // get (with fake set)
#define WEAPON_RELOADTIME 126 // get (with fake set)
#define WEAPON_ACCURACY 127 // get (with fake set)
#define WEAPON_SPRAY 128 // get (with fake set)
#define WEAPON_RANGE 129 // get (with fake set)
#define WEAPON_PROJECTILE_SPEED 130 // get (with fake set)
#define MIN 131 // get
#define MAX 132 // get
#define ABS 133 // get
#define GAME_FRAME 134 // get
#define KSIN 135 // get (kiloSine : 1024*sin(x))
#define KCOS 136 // get (kiloCosine : 1024*cos(x))
#define KTAN 137 // get (kiloTangent : 1024*tan(x))
#define SQRT 138 // get (square root)