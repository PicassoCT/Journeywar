

include "lib_OS.lua"
include "lib_UnitScript.lua" 
include "lib_Animation.lua"

include "lib_Build.lua" 

TableOfPieces={}
center = piece("center")
TableOfPieces[#TableOfPieces+1]= center
Erker4 = piece("Erker4")
TableOfPieces[#TableOfPieces+1]= Erker4
InnerLoop10 = piece("InnerLoop10")
TableOfPieces[#TableOfPieces+1]= InnerLoop10
InnerLoop1 = piece("InnerLoop1")
TableOfPieces[#TableOfPieces+1]= InnerLoop1
InnerLoop2 = piece("InnerLoop2")
TableOfPieces[#TableOfPieces+1]= InnerLoop2
InnerLoop3 = piece("InnerLoop3")
TableOfPieces[#TableOfPieces+1]= InnerLoop3
InnerLoop4 = piece("InnerLoop4")
TableOfPieces[#TableOfPieces+1]= InnerLoop4
InnerLoop5 = piece("InnerLoop5")
TableOfPieces[#TableOfPieces+1]= InnerLoop5
InnerLoop6 = piece("InnerLoop6")
TableOfPieces[#TableOfPieces+1]= InnerLoop6
InnerLoop7 = piece("InnerLoop7")
TableOfPieces[#TableOfPieces+1]= InnerLoop7
InnerLoop8 = piece("InnerLoop8")
TableOfPieces[#TableOfPieces+1]= InnerLoop8
InnerLoop9 = piece("InnerLoop9")
TableOfPieces[#TableOfPieces+1]= InnerLoop9
InnerLoopC = piece("InnerLoopC")
TableOfPieces[#TableOfPieces+1]= InnerLoopC
NGon085 = piece("NGon085")
TableOfPieces[#TableOfPieces+1]= NGon085
NGon086 = piece("NGon086")
TableOfPieces[#TableOfPieces+1]= NGon086
NGon089 = piece("NGon089")
TableOfPieces[#TableOfPieces+1]= NGon089
NGon090 = piece("NGon090")
TableOfPieces[#TableOfPieces+1]= NGon090
NGon088 = piece("NGon088")
TableOfPieces[#TableOfPieces+1]= NGon088
Gun3 = piece("Gun3")
TableOfPieces[#TableOfPieces+1]= Gun3
Mag5 = piece("Mag5")
TableOfPieces[#TableOfPieces+1]= Mag5
Mag6 = piece("Mag6")
TableOfPieces[#TableOfPieces+1]= Mag6
Erker3 = piece("Erker3")
TableOfPieces[#TableOfPieces+1]= Erker3
Erker2 = piece("Erker2")
TableOfPieces[#TableOfPieces+1]= Erker2
NGon087 = piece("NGon087")
TableOfPieces[#TableOfPieces+1]= NGon087
InnerOrigin = piece("InnerOrigin")
TableOfPieces[#TableOfPieces+1]= InnerOrigin
OuterLoop12 = piece("OuterLoop12")
TableOfPieces[#TableOfPieces+1]= OuterLoop12
OuterLoop24 = piece("OuterLoop24")
TableOfPieces[#TableOfPieces+1]= OuterLoop24
OuterLoop27 = piece("OuterLoop27")
TableOfPieces[#TableOfPieces+1]= OuterLoop27
Gun1 = piece("Gun1")
TableOfPieces[#TableOfPieces+1]= Gun1
Mag1 = piece("Mag1")
TableOfPieces[#TableOfPieces+1]= Mag1
Mag2 = piece("Mag2")
TableOfPieces[#TableOfPieces+1]= Mag2
OuterLoop25 = piece("OuterLoop25")
TableOfPieces[#TableOfPieces+1]= OuterLoop25
OuterLoop29 = piece("OuterLoop29")
TableOfPieces[#TableOfPieces+1]= OuterLoop29
Gun4 = piece("Gun4")
TableOfPieces[#TableOfPieces+1]= Gun4
Mag7 = piece("Mag7")
TableOfPieces[#TableOfPieces+1]= Mag7
Mag8 = piece("Mag8")
TableOfPieces[#TableOfPieces+1]= Mag8
OuterLoop30 = piece("OuterLoop30")
TableOfPieces[#TableOfPieces+1]= OuterLoop30
OuterLoop31 = piece("OuterLoop31")
TableOfPieces[#TableOfPieces+1]= OuterLoop31
OuterLoop32 = piece("OuterLoop32")
TableOfPieces[#TableOfPieces+1]= OuterLoop32
OuterLoop35 = piece("OuterLoop35")
TableOfPieces[#TableOfPieces+1]= OuterLoop35
OuterLoop36 = piece("OuterLoop36")
TableOfPieces[#TableOfPieces+1]= OuterLoop36
OuterLoop37 = piece("OuterLoop37")
TableOfPieces[#TableOfPieces+1]= OuterLoop37
OuterLoop38 = piece("OuterLoop38")
TableOfPieces[#TableOfPieces+1]= OuterLoop38
OuterLoop39 = piece("OuterLoop39")
TableOfPieces[#TableOfPieces+1]= OuterLoop39
Erker5 = piece("Erker5")
TableOfPieces[#TableOfPieces+1]= Erker5
Erker6 = piece("Erker6")
TableOfPieces[#TableOfPieces+1]= Erker6
OuterLoop34 = piece("OuterLoop34")
TableOfPieces[#TableOfPieces+1]= OuterLoop34
OuterLoop40 = piece("OuterLoop40")
TableOfPieces[#TableOfPieces+1]= OuterLoop40
OuterLoop41 = piece("OuterLoop41")
TableOfPieces[#TableOfPieces+1]= OuterLoop41
OuterLoop43 = piece("OuterLoop43")
TableOfPieces[#TableOfPieces+1]= OuterLoop43
RailGun = piece("RailGun")
TableOfPieces[#TableOfPieces+1]= RailGun
Projectile = piece("Projectile")
TableOfPieces[#TableOfPieces+1]= Projectile
DronePod1 = piece("DronePod1")
TableOfPieces[#TableOfPieces+1]= DronePod1
DronePod2 = piece("DronePod2")
TableOfPieces[#TableOfPieces+1]= DronePod2
OuterLoop33 = piece("OuterLoop33")
TableOfPieces[#TableOfPieces+1]= OuterLoop33
OuterLoop42 = piece("OuterLoop42")
TableOfPieces[#TableOfPieces+1]= OuterLoop42
OuterLoop44 = piece("OuterLoop44")
TableOfPieces[#TableOfPieces+1]= OuterLoop44
OuterLoop47 = piece("OuterLoop47")
TableOfPieces[#TableOfPieces+1]= OuterLoop47
OuterLoop55 = piece("OuterLoop55")
TableOfPieces[#TableOfPieces+1]= OuterLoop55
Erker9 = piece("Erker9")
TableOfPieces[#TableOfPieces+1]= Erker9
Erker10 = piece("Erker10")
TableOfPieces[#TableOfPieces+1]= Erker10
OuterLoop54 = piece("OuterLoop54")
TableOfPieces[#TableOfPieces+1]= OuterLoop54
DronePod3 = piece("DronePod3")
TableOfPieces[#TableOfPieces+1]= DronePod3
Erker11 = piece("Erker11")
TableOfPieces[#TableOfPieces+1]= Erker11
OuterLoop50 = piece("OuterLoop50")
TableOfPieces[#TableOfPieces+1]= OuterLoop50
OuterLoop51 = piece("OuterLoop51")
TableOfPieces[#TableOfPieces+1]= OuterLoop51
DronePod4 = piece("DronePod4")
TableOfPieces[#TableOfPieces+1]= DronePod4
OuterLoop45 = piece("OuterLoop45")
TableOfPieces[#TableOfPieces+1]= OuterLoop45
OuterLoop46 = piece("OuterLoop46")
TableOfPieces[#TableOfPieces+1]= OuterLoop46
OuterLoop53 = piece("OuterLoop53")
TableOfPieces[#TableOfPieces+1]= OuterLoop53
OuterLoop52 = piece("OuterLoop52")
TableOfPieces[#TableOfPieces+1]= OuterLoop52
Erker1 = piece("Erker1")
TableOfPieces[#TableOfPieces+1]= Erker1
Erker8 = piece("Erker8")
TableOfPieces[#TableOfPieces+1]= Erker8
OuterLoop48 = piece("OuterLoop48")
TableOfPieces[#TableOfPieces+1]= OuterLoop48
OuterLoop49 = piece("OuterLoop49")
TableOfPieces[#TableOfPieces+1]= OuterLoop49
Erker7 = piece("Erker7")
TableOfPieces[#TableOfPieces+1]= Erker7
DronePod5 = piece("DronePod5")
TableOfPieces[#TableOfPieces+1]= DronePod5
Wall = piece("Wall")
TableOfPieces[#TableOfPieces+1]= Wall
GatePoint = piece("GatePoint")
TableOfPieces[#TableOfPieces+1]= GatePoint
RingB = piece("RingB")
TableOfPieces[#TableOfPieces+1]= RingB
Ring0 = piece("Ring0")
TableOfPieces[#TableOfPieces+1]= Ring0
GatePortal = piece("GatePortal")
TableOfPieces[#TableOfPieces+1]= GatePortal
GateWave = piece("GateWave")
TableOfPieces[#TableOfPieces+1]= GateWave
WaveA = piece("WaveA")
TableOfPieces[#TableOfPieces+1]= WaveA
Feed10 = piece("Feed10")
TableOfPieces[#TableOfPieces+1]= Feed10
Feed9 = piece("Feed9")
TableOfPieces[#TableOfPieces+1]= Feed9
Feed8 = piece("Feed8")
TableOfPieces[#TableOfPieces+1]= Feed8
Feed7 = piece("Feed7")
TableOfPieces[#TableOfPieces+1]= Feed7
Feed6 = piece("Feed6")
TableOfPieces[#TableOfPieces+1]= Feed6
Feed5 = piece("Feed5")
TableOfPieces[#TableOfPieces+1]= Feed5
Feed4 = piece("Feed4")
TableOfPieces[#TableOfPieces+1]= Feed4
Feed3 = piece("Feed3")
TableOfPieces[#TableOfPieces+1]= Feed3
Feed2 = piece("Feed2")
TableOfPieces[#TableOfPieces+1]= Feed2
Feed1 = piece("Feed1")
TableOfPieces[#TableOfPieces+1]= Feed1
Ring3 = piece("Ring3")
TableOfPieces[#TableOfPieces+1]= Ring3
Ring2 = piece("Ring2")
TableOfPieces[#TableOfPieces+1]= Ring2
Ring1 = piece("Ring1")
TableOfPieces[#TableOfPieces+1]= Ring1
BigLUpCenter = piece("BigLUpCenter")
TableOfPieces[#TableOfPieces+1]= BigLUpCenter
OuterLoop13 = piece("OuterLoop13")
TableOfPieces[#TableOfPieces+1]= OuterLoop13
OuterLoop14 = piece("OuterLoop14")
TableOfPieces[#TableOfPieces+1]= OuterLoop14
OuterLoop15 = piece("OuterLoop15")
TableOfPieces[#TableOfPieces+1]= OuterLoop15
OuterLoop16 = piece("OuterLoop16")
TableOfPieces[#TableOfPieces+1]= OuterLoop16
OuterLoop17 = piece("OuterLoop17")
TableOfPieces[#TableOfPieces+1]= OuterLoop17
OuterLoop18 = piece("OuterLoop18")
TableOfPieces[#TableOfPieces+1]= OuterLoop18
OuterLoop19 = piece("OuterLoop19")
TableOfPieces[#TableOfPieces+1]= OuterLoop19
OuterLoop20 = piece("OuterLoop20")
TableOfPieces[#TableOfPieces+1]= OuterLoop20
OuterLoop21 = piece("OuterLoop21")
TableOfPieces[#TableOfPieces+1]= OuterLoop21
OuterLoop22 = piece("OuterLoop22")
TableOfPieces[#TableOfPieces+1]= OuterLoop22
OuterLoop23 = piece("OuterLoop23")
TableOfPieces[#TableOfPieces+1]= OuterLoop23

BigLCenter = piece("BigLCenter")
TableOfPieces[#TableOfPieces+1]= BigLCenter
OuterLoop10 = piece("OuterLoop10")
TableOfPieces[#TableOfPieces+1]= OuterLoop10
OuterLoop11 = piece("OuterLoop11")
TableOfPieces[#TableOfPieces+1]= OuterLoop11

UpGo1 = piece("UpGo1")
TableOfPieces[#TableOfPieces+1]= UpGo1 
UpGo2 = piece("UpGo2")
TableOfPieces[#TableOfPieces+1]= UpGo2 

OuterLoop1 = piece("OuterLoop1")
TableOfPieces[#TableOfPieces+1]= OuterLoop1 

OuterLoop56 = piece("OuterLoop56")
TableOfPieces[#TableOfPieces+1]= OuterLoop56
OuterLoop26 = piece("OuterLoop26")
TableOfPieces[#TableOfPieces+1]= OuterLoop26
OuterLoop28 = piece("OuterLoop28")
TableOfPieces[#TableOfPieces+1]= OuterLoop28
Gun2 = piece("Gun2")
TableOfPieces[#TableOfPieces+1]= Gun2
Mag3 = piece("Mag3")
TableOfPieces[#TableOfPieces+1]= Mag3
Mag4 = piece("Mag4")
TableOfPieces[#TableOfPieces+1]= Mag4
OuterLoop2 = piece("OuterLoop2")
TableOfPieces[#TableOfPieces+1]= OuterLoop2
OuterLoop3 = piece("OuterLoop3")
TableOfPieces[#TableOfPieces+1]= OuterLoop3
OuterLoop4 = piece("OuterLoop4")
TableOfPieces[#TableOfPieces+1]= OuterLoop4
OuterLoop5 = piece("OuterLoop5")
TableOfPieces[#TableOfPieces+1]= OuterLoop5
OuterLoop6 = piece("OuterLoop6")
TableOfPieces[#TableOfPieces+1]= OuterLoop6
OuterLoop7 = piece("OuterLoop7")
TableOfPieces[#TableOfPieces+1]= OuterLoop7
OuterLoop8 = piece("OuterLoop8")
TableOfPieces[#TableOfPieces+1]= OuterLoop8
OuterLoop9 = piece("OuterLoop9")
TableOfPieces[#TableOfPieces+1]= OuterLoop9
CatapultRoto1 = piece("CatapultRoto1")
TableOfPieces[#TableOfPieces+1]= CatapultRoto1
CataLow1 = piece("CataLow1")
TableOfPieces[#TableOfPieces+1]= CataLow1
CataUp1 = piece("CataUp1")
TableOfPieces[#TableOfPieces+1]= CataUp1
CataHead1 = piece("CataHead1")
TableOfPieces[#TableOfPieces+1]= CataHead1
CatapultRoto2 = piece("CatapultRoto2")
TableOfPieces[#TableOfPieces+1]= CatapultRoto2
CataLow2 = piece("CataLow2")
TableOfPieces[#TableOfPieces+1]= CataLow2
CataUp2 = piece("CataUp2")
TableOfPieces[#TableOfPieces+1]= CataUp2
CataHead2 = piece("CataHead2")
TableOfPieces[#TableOfPieces+1]= CataHead2
InLoopCenter = piece("InnerLoopC")
TableOfPieces[#TableOfPieces+1]= InLoopCenter


TablesOfPiecesGroups={}--=makePiecesTablesByNameGroups(false,true)
UpTable={}
SeedTable={}

for i=1,12,1 do
	val=i+12
	name="OuterLoop"..(val)
	piecenumber=piece(name)
	UpTable[#UpTable+1]=piecenumber
end
for i=1,10 do
	name="Seed"..(i)
	piecenumber=piece(name)
	SeedTable[i]=piecenumber
end
Feed={}
OuterLoopTable={}

Mag={}
Ring={}
InnerLoop={}
GunTable={}
DronePodTable={}

--Constants
feed_speed=53
GateDeg=-15
LengthFeed=53
FeedTime=1.1666666666666
InnerLoopRadius=82
boolActivateTravelling= false

function script.HitByWeapon ( x, z, weaponDefID, damage ) 
return damage
end


function script.Create()
	
	TablesOfPiecesGroups=makePiecesTablesByNameGroups(false,true)
	Feed=TablesOfPiecesGroups["Feed"]
	hideT(SeedTable)
	OuterLoopTable=TablesOfPiecesGroups["OuterLoop"]
	Mag=TablesOfPiecesGroups["Mag"]
	Ring=TablesOfPiecesGroups["Ring"]
	InnerLoop=TablesOfPiecesGroups["InnerLoop"]
	GunTable=TablesOfPiecesGroups["Gun"]
	CataRoto=TablesOfPiecesGroups["CatapultRoto"]
	CataLow=TablesOfPiecesGroups["CataLow"]
	CataUp=TablesOfPiecesGroups["CataUp"]
	CataHead=TablesOfPiecesGroups["CataHead"]
	DronePodTable=TablesOfPiecesGroups["DronePod"]

	
	for i=1,#Mag do
		Sign=i%2
		if Sign==0 then Sign=-1 end
		Spin(Mag[i],z_axis,math.rad(42*Sign),0)
	end
	x,y,z=Spring.GetUnitPiecePosDir(unitID,RingB)
	
	hideT(TableOfPieces)
	--generatepiecesTableAndArrayCode(unitID)
	StartThread(AnimTest)
	
end

function script.Killed(recentDamage,_)
	return 1
end

DeTa={}
DeTa[DronePod1]={x= 0,y=0,	z=-3.4}
DeTa[DronePod2]={x= 0,y=0,	z=3.4}
DeTa[DronePod3]={x= 0,y=0,z=-3.4}
DeTa[DronePod4]={x= -4.3,y=0,z=0}
DeTa[DronePod5]={x= 4.3,y=0,z=0}

DeTa[Erker1]={x= 0 ,y=0,z=-5.3}
DeTa[Erker2]={x= -5.3,y=0,z=0}
DeTa[Erker3]={x= -5.3,y=0,z=0}
DeTa[Erker4]={x= 0,y=0,z=-5.3}
DeTa[Erker5]={x= -5.3,y=0,z=-5.3}
DeTa[Erker6]={x= 5.3,y=0,z=-5.3}
DeTa[Erker7]={x= 5.3,y=0,z=0}
DeTa[Erker8]={x= -5.3,y=0,z=0}
DeTa[Erker9]={x= -5.3,y=0,z=0}
DeTa[Erker10]={x= 5.3,y=0,z=0}
DeTa[Erker11]={x= 5.3,y=0,z=0}

unfoldDepotSpeed=4.25
function unfoldDepots(boolDirection)
	if boolDirection==true then
		for piecename, tab in pairs(DeTa) do
			mP(piecename,tab.x*-1,tab.y,tab.z,0)
			Show(piecename)
			mP(piecename,0,0,0,unfoldDepotSpeed)
		end
	else
		
		lastPieceName=""
		for piecename, tab in pairs(DeTa) do
			mP(piecename,tab.x*-1,tab.y,tab.z,unfoldDepotSpeed)
			lastPieceName=piecename
		end
		WaitForMove(lastPieceName,x_axis)
		WaitForMove(lastPieceName,y_axis)
		WaitForMove(lastPieceName,z_axis)
		for piecename, tab in pairs(DeTa) do
			Hide(piecename)
		end
	end
end

function AnimTest()
	while true do 
		unfoldAnimation()
		Sleep(1000)
		foldAnimation()
		Sleep(1000)
	end
	
end

local PI=3.1415926535897932384626433832795
SignalTable={}


soundInOrderTableUnfold={}
soundInOrderTableUnfold[1]={boolOnce=true,postdelay=0,predelay=3000,sound="sounds/cgatefortress/GateOPen.ogg"}
soundInOrderTableUnfold[2]={boolOnce=false, postdelay=2500,sound={[1]="sounds/cgatefortress/GateLoop1.ogg",[2]="sounds/cgatefortress/GateLoop.ogg",[3]="sounds/cgatefortress/GateLoop2.ogg"}}
soundInOrderTableUnfold[3]={boolOnce=false, postdelay=2500,sound={[1]="sounds/cgatefortress/GateOnly1.ogg",[2]="sounds/cgatefortress/GateOnly2.ogg"}}
 
 if not GG.soundInOrderTable then  GG.soundInOrderTable ={} end
 if not GG.soundInOrderTable["cgatefort"..unitID] then   GG.soundInOrderTable["cgatefort"..unitID]={signal= true} end
 

function unfoldAnimation()
	
	resetT(TableOfPieces)
	hideT(TableOfPieces)
	--randoVal=iRand(-360,360)
	--Turn(center,y_axis,math.rad(randoVal),0)
	Sleep(10)
	StartThread(playSoundInOrder,soundInOrderTableUnfold,"cgatefort"..unitID)
	
	GateDeploy( true)	
	StartThread(GateLoop ,true)
	
	FirstTrainDeploy(true)	
	StartThread(TrainLoop ,true)
	
	InnerCircleDeploy(true)	
	
	StartThread(InnerCircleLoop ,true)
	
	OuterCircleDeploy( true)		

	StartThread(GoUp ,true,2*PI*0.1 *(1/1.1666 ))


	StartThread(OuterCircleLoop ,true)
	
	
	UpperCircleDeploy( true)
	
	StartThread(UpperCircleLoop ,true,4)
	

	TowerDeploy(true)

	DeployInOrder(true)


	
	InnerCityDeploy(true)
	RailGunUnfold(true)
	unfoldDepots(true)
	GG.soundInOrderTable["cgatefort"..unitID].signal=false

	boolDeployed=true
	for k,v in pairs(SignalTable)do 
	SignalTable[k]=false	
	end
	
end

function foldAnimation()
	Sleep(10)
	
	StartThread(playSoundInOrder,soundInOrderTableUnfold,"cgatefort"..unitID)
	StartThread(GateLoop ,false)
	boolDeployed=false

	
		RailGunUnfold(false)
		InnerCityDeploy(false)
		DeployInOrder(false)
		TowerDeploy(false)
		UpperCircleDeploy(false)
		StartThread(GoUp ,false,2*PI*0.1 *(1/1.1666 ))
		StartThread(OuterCircleLoop ,false)
		OuterCircleDeploy( false)		
		StartThread(InnerCircleLoop ,false)

	InnerCircleDeploy(false)	
	
	StartThread(TrainLoop ,false)

	FirstTrainDeploy(false)	
	
	Sleep(10)
	
	GateDeploy( false)	

	boolOnTheMove=true
	hideT(TableOfPieces)

	resetT(TableOfPieces)
	hideT(TableOfPieces)
	GG.soundInOrderTable["cgatefort"..unitID].signal=false

	for k,v in pairs(SignalTable)do 
	SignalTable[k]=false	
	end
end

boolDeployed=false
boolOnTheMove=false 
boolOneShot=true 
teamid=Spring.GetUnitTeam(unitID)


function GateDeploy (boolReverse) 
	
	
	if boolReverse==true then
		Sleep(3000)
		Turn(GatePoint,y_axis,math.rad(GateDeg),9)
		--Preparation
		Move(center,y_axis,2.5,0)
		Move(Ring0,y_axis,-15,0)
		Turn(Ring0,y_axis,math.rad(-90),0)
		ShowKill(Ring0)
		Show(RingB)
		Turn(Ring0,y_axis,math.rad(0),1.2)
		moveExpPiece(Ring0,y_axis,15,-15,5,750,15,false)
		Move(Ring0,y_axis,0,35)
		WaitForMove(Ring0,y_axis)
		Turn(Ring3,x_axis,math.rad(180+46),0)
		Turn(Ring2,x_axis,math.rad(180+2*46),0)
		Turn(Ring1,x_axis,math.rad(180+3*46),0)
		WaitForTurn(Ring3,x_axis)
		WaitForTurn(Ring2,x_axis)
		WaitForTurn(Ring1,x_axis)
		Turn(Ring1,x_axis,math.rad(0),10)				
		Show(Ring1)
		WaitForTurn(Ring1,x_axis)
		Turn(Ring2,x_axis,math.rad(0),10)
		Show(Ring2)
		WaitForTurn(Ring2,x_axis)
		Turn(Ring3,x_axis,math.rad(0),10)
		Show(Ring3)
		WaitForTurn(Ring3,x_axis)
		Show(GatePortal)
		Spin(GatePortal,x_axis,math.rad(42),0)
		
	else
		
		Turn(GatePoint,y_axis,math.rad(GateDeg),9)
		--Preparation
	

		Hide(GatePortal)

		Show(Ring3)
		WaitForTurn(Ring3,x_axis)
			Turn(Ring3,x_axis,math.rad(0),10)
		WaitForTurn(Ring2,x_axis)
			Show(Ring2)
			Turn(Ring2,x_axis,math.rad(0),10)
		WaitForTurn(Ring1,x_axis)
	Show(Ring1)
			Turn(Ring1,x_axis,math.rad(0),10)				
		WaitForTurns(Ring1,Ring2,Ring3)
			Turn(Ring3,x_axis,math.rad(180+46),0)
		Turn(Ring2,x_axis,math.rad(180+2*46),0)
		Turn(Ring1,x_axis,math.rad(180+3*46),0)
		Move(Ring0,y_axis,0,35)
		WaitForMove(Ring0,y_axis)
		moveExpPiece(Ring0,y_axis,15,-15,5,750,15,false)
		Turn(Ring0,y_axis,math.rad(0),1.2)
			Show(RingB)
		ShowKill(Ring0)
	
			Turn(Ring0,y_axis,math.rad(-90),0)
	Move(center,y_axis,2.5,0)
		Move(Ring0,y_axis,-15,0)

	
	end 
	
	
end

function GateLoop (boolReverse) 
	AlterRate=0
	SignalTable["GateLoop"]=true
	while SignalTable["GateLoop"]==true do
		AlterRate=AlterRate+1
		Spin(GateWave,x_axis,math.rad(42),0)
		Spin(WaveA,x_axis,math.rad(42),0)
		Show(GateWave)
		Show(WaveA)
		speed=math.random(1.5,4)
		if maRo() then
			if AlterRate % 2==1 then
				Move(GateWave,x_axis,-5.5,speed)
			end
			
			if AlterRate % 2==0 then
				Move(WaveA,x_axis,-3.14,speed)
			end
		end					
		
		WaitForMove(WaveA,x_axis)
		WaitForMove(GateWave,x_axis)
		Move(WaveA,x_axis,0,speed)
		Move(GateWave,x_axis,0,speed)
		WaitForMove(WaveA,x_axis)
		WaitForMove(GateWave,x_axis)
		
		
		Sleep(10)
	end
	--HoldPosition
	
end

function FirstTrainDeploy (boolReverse) 
	boolDirection= false 
	if boolReverse then boolDirection =boolReverse end
	--if the animation should be aborted, we revert it 
	
	
	if boolDirection==true then
		
		WMove(Feed10,x_axis,0,0)
		count_up=0
		
		for i=0,-LengthFeed,-4.8 do
			WMove(Feed10,x_axis,i,feed_speed)
			if 	 Feed[count_up] then			
				ShowKill(Feed[count_up])
			end
			count_up=math.min(count_up+1,9)
		end
		
		Show(Feed10)
		hideT(Feed)
	else
		
		
		
	end 
	
end
function TrainLoop (boolReverse) 

	SignalTable["TrainLoop"]=true
	
	while SignalTable["TrainLoop"]==true do
		if boolReverse==true then		
			WMove(Feed10,x_axis,0,0)
			count_up=0
			
			for i=0,-LengthFeed,-4.8 do
				WMove(Feed10,x_axis,i,feed_speed)
				if 	 Feed[count_up] then			
					Show(Feed[count_up])
				end
				count_up=math.min(count_up+1,9)
			end
			Show(Feed10)
			WMove(Feed10,x_axis,-LengthFeed,feed_speed)
			hideT(Feed)
		else
			WMove(Feed10,x_axis,LengthFeed,0)
			count_up=0
			showT(Feed)
			for i=LengthFeed,0,-4.8 do
				WMove(Feed10,x_axis,i,feed_speed)
				if 	 Feed[count_up] then			
					Hide(Feed[count_up])
				end
				count_up=math.min(count_up+1,9)
			end
			
			
			
		end 
	end
	
end


innerCircleIterator=0
function InnerCircleDeploy (boolReverse) 
	boolDirection= false 
	if boolReverse then boolDirection =boolReverse end
	--if the animation should be aborted, we revert it 
	
	
	radialSpeed= 2*PI*0.1 *(1/1.1666 )
	
	hideT(InnerLoop)
	
	if boolDirection==true then
		
		for inner=1,10,1 do
			ShowKill(InnerLoop[inner])
			Turn(InLoopCenter,y_axis,math.rad(inner*-36 ),radialSpeed)
			WaitForTurn(InLoopCenter,y_axis)
			if InnerLoop[inner-3] then
				Hide(InnerLoop[inner-3])
			end
			if inner ==4 then					
				
				return 
			end
		end
		
	else
	end 
	
	
end

SeedCenter=piece"SeedCenter"
function SeedLoop(nrOfPumps,feed_speed,boolDirection,radialSpeed)
	
	for k=1,nrOfPumps,1 do
		
		
		offSet={}
		offSet.x,offSet.y,offSet.z=0,0,0
		WMove(SeedTable[10],x_axis,0,0)
		if boolDirection==true then	
			seed_count_up=0		
			hideT(SeedTable)
			for seedIndex=0,-LengthFeed,-4.8 do
				WMove(SeedTable[10],x_axis,seedIndex,feed_speed)
				if 	SeedTable[seed_count_up] then			
					Show(SeedTable[seed_count_up])
				end
				seed_count_up=math.min(seed_count_up+1,10)
			end
			hideT(SeedTable)
			
		else
			seed_count_up=10
			WMove(SeedTable[10],x_axis,LengthFeed,0)
			showT(SeedTable)
			for seedIndex=LengthFeed,0,-4.8 do
				WMove(SeedTable[10],x_axis,seedIndex,feed_speed)
				if 	SeedTable[seed_count_up] then			
					Hide(SeedTable[seed_count_up])
				end
				seed_count_up=math.max(seed_count_up-1,1)
			end
			hideT(SeedTable)
		end
	end
	
	
end

function InnerCircleLoop (boolReverse) 
	boolDirection= false ; 	if boolReverse then boolDirection =boolReverse end
	SignalTable["InnerCircleLoop"]=true	
	
	radialSpeed=2*PI*0.10 *(1/1.1666 )
	
	inner=4
	while SignalTable["InnerCircleLoop"]==true do
		
		if boolDirection==true then
			
			
			
			Show(InnerLoop[inner])
			Turn(InLoopCenter,y_axis,math.rad(inner*-36 ),radialSpeed)
			
			WaitForTurn(InLoopCenter,y_axis)
			offSet= ((inner+6)%10) +1
			
			if InnerLoop[offSet] then
				Hide(InnerLoop[offSet] )
			end
			inner=inner%10+1
			
			
			
		else
						
			Show(InnerLoop[inner])
			Turn(InLoopCenter,y_axis,math.rad(inner*36 ),radialSpeed)
			
			WaitForTurn(InLoopCenter,y_axis)
			offSet= ((inner+6)%10) +1
			
			if InnerLoop[offSet] then
				Hide(InnerLoop[offSet] )
			end
			inner=inner%10+1
				
		end 
	end
	Hide(InnerLoop[inner])
	
	
end

function OuterCircleDeploy (boolReverse) 
	boolDirection= boolReverse 
	
	out_radialSpeed= 2*PI*0.08333333333333333333 *(1/1.1666 )
	
	hideT(OuterLoopTable)
	
	if boolDirection==true then
		Turn(BigLCenter,y_axis,math.rad(-5),0)
		WaitForTurn(BigLCenter,y_axis)
		for out=1,12,1 do
			
			temp=((out+1)%12)+1			
			ShowKill(OuterLoopTable[temp])
			Turn(BigLCenter,y_axis,math.rad(out*-30 +25),out_radialSpeed)
			WaitForTurn(BigLCenter,y_axis)
			
			if OuterLoopTable[out-7] then
				Hide(OuterLoopTable[out-7])
				return
			end
		end
		
		
	else
	end 
	
	
	
end

UpGoTurn1=piece"UpGoTurn1"
UpGoTurn2=piece"UpGoTurn2"

function ShowKill(piecename)
	killAtPiece(unitID,piecename)
	Show(piecename)
end

function OuterCircleLoop (boolReverse) 
	boolDirection= false ; 	if boolReverse then boolDirection =boolReverse end
	SignalTable["OuterCircleLoop"]=true
	
	
	Show(UpGo1)
	Show(UpGo2)
	
	
	out_radialSpeed= 2*PI*0.08333333333333333333 *(1/1.1666 )
	
	out=8
	Show(OuterLoopTable[6])
	Show(OuterLoopTable[7])
	Show(OuterLoopTable[8])
	Show(OuterLoopTable[9])
	Show(OuterLoopTable[10])
	Turn(BigLCenter,y_axis,math.rad(-215),0,true)
	WaitForTurn(BigLCenter,y_axis)
	
	while SignalTable["OuterCircleLoop"]==true do
		
		if boolDirection==true then
			
			
			temp=((out+1)%12)+1
			
			
			Show(OuterLoopTable[temp])
			Turn(BigLCenter,y_axis,math.rad(out*-30 +25),radialSpeed)
			
			WaitForTurn(BigLCenter,y_axis)
			offSet= ((out+5)%12) +1
			
			if SignalTable["OuterCircleLoop"]==false then 
				
			return end
			Hide(OuterLoopTable[offSet] )
			
			
			out=out%12+1
			
			
			
		else
					
			temp=((out-1)%12)-1
			if temp <= 0 then temp = 12 end
			
			Show(OuterLoopTable[temp])
			Turn(BigLCenter,y_axis,math.rad(out*30 +25),radialSpeed)
			
			WaitForTurn(BigLCenter,y_axis)
			offSet= ((out+5)%12) +1
			
			if SignalTable["OuterCircleLoop"]==false then 
				
			return end
			Hide(OuterLoopTable[offSet] )
			
			
			out=out%12-1
			if out <= 0 then out =12 end
			
			
		
		
		end 
	end
	
	
end

function GoUp(boolReverse,radialSpeed)
	boolDirection= false ; 	if boolReverse then boolDirection =boolReverse end
	
	SignalTable["GoUp"]=true
	
	
	offset=30	
	
	if boolDirection==true then
		
		while SignalTable["GoUp"]==true do
			Hide(UpGo1)
			Hide(UpGo2)	
			Turn(UpGoTurn2,y_axis,math.rad(0+offset),0)
			Turn(UpGoTurn1,y_axis,math.rad(30+offset),0)	
			
			Turn(UpGo2,x_axis,math.rad(0),0)	
			Turn(UpGo1,x_axis,math.rad(-20),0)
			
			WaitForTurn(UpGoTurn1,y_axis)
			WaitForTurn(UpGoTurn2,y_axis)
			WaitForTurn(UpGo2,x_axis)
			WaitForTurn(UpGo1,x_axis)
			Show(UpGo1)
			Show(UpGo2)	
			Turn(UpGo2,x_axis,math.rad(-20),0.35)	
			Turn(UpGo1,x_axis,math.rad(0),0.35)	
			Turn(UpGoTurn2,y_axis,math.rad(0),radialSpeed)
			Turn(UpGoTurn1,y_axis,math.rad(30),radialSpeed)		
			WaitForTurn(UpGoTurn1,y_axis)
			WaitForTurn(UpGoTurn2,y_axis)
		end
		
	else
		while SignalTable["GoUp"]==true do
			Hide(UpGo1)			
			Hide(UpGo2)	
			
			Turn(UpGo2,x_axis,math.rad(-20),0)	
			Turn(UpGo1,x_axis,math.rad(0),0)	
			Turn(UpGoTurn2,y_axis,math.rad(0),0)
			Turn(UpGoTurn1,y_axis,math.rad(30),0)	
			WaitForTurn(UpGoTurn1,y_axis)
			WaitForTurn(UpGoTurn2,y_axis)
			Show(UpGo1)			
			Show(UpGo2)				
				Turn(UpGo2,x_axis,math.rad(0),0.35)	
			Turn(UpGo1,x_axis,math.rad(-20),0.35)
			Turn(UpGoTurn2,y_axis,math.rad(0+offset),radialSpeed)
			Turn(UpGoTurn1,y_axis,math.rad(30+offset),radialSpeed)	
			
			WaitForTurn(UpGoTurn1,y_axis)
			WaitForTurn(UpGoTurn2,y_axis)
			WaitForTurn(UpGo2,x_axis)
			WaitForTurn(UpGo1,x_axis)
		
		
		end
	end 
	
end



function UpperCircleDeploy (boolReverse) 
	boolDirection= false 
	if boolReverse then boolDirection =boolReverse end
	--if the animation should be aborted, we revert it 
	
	--12
	out_radialSpeed= 2*PI*0.08333333333333333333 *(1/1.1666 )
	
	
	if boolDirection==true then
		Turn(BigLUpCenter,y_axis,math.rad(60),0)
		WaitForTurn(BigLUpCenter,y_axis)
		for upcircdepindex=0,12,1 do
			
			temp=((upcircdepindex)%12)+1
			
			if UpTable[upcircdepindex] then Show(UpTable[upcircdepindex]) end
			
			Turn(BigLUpCenter,y_axis,math.rad(upcircdepindex*-30+30 ),out_radialSpeed)
			WaitForTurn(BigLUpCenter,y_axis)
			
			if UpTable[upcircdepindex-9] then
				Hide(UpTable[upcircdepindex-9])
				
			end
		end
		
		
	else
	end 
	
	
end

UpGoTurn1=piece"UpGoTurn1"
UpGoTurn2=piece"UpGoTurn2"



function UpperCircleLoop (boolReverse,totalLength) 
	boolDirection= false ; 	if boolReverse then boolDirection =boolReverse end
	SignalTable["UpperCircleLoop"]=true
	
	upperCircOutIndex=10
	Counter=0
	Turn(BigLUpCenter,y_axis,math.rad(-270),0,true)
	WaitForTurn(BigLUpCenter,y_axis)
	
	while SignalTable["UpperCircleLoop"]==true do
		
		if boolDirection==true then
			temp=((upperCircOutIndex)%12)+1
			
			
			Turn(BigLUpCenter,y_axis,math.rad(upperCircOutIndex*-30 ),radialSpeed)
			WaitForTurn(BigLUpCenter,y_axis)
			if UpTable[temp] then	Show(UpTable[temp])	end	
			upperloopoffSet= upperCircOutIndex-6
			if upperloopoffSet < 1 then upperloopoffSet =upperloopoffSet+12 end
			
			if UpTable[upperloopoffSet] then Hide(UpTable[upperloopoffSet] )	end
			
			upperCircOutIndex=upperCircOutIndex%12+1
		else
			Turn(BigLUpCenter,y_axis,math.rad(upperCircOutIndex*30 ),radialSpeed)
			WaitForTurn(BigLUpCenter,y_axis)
			if UpTable[temp] then	Show(UpTable[temp])	end	
			upperloopoffSet= upperCircOutIndex-6
			if upperloopoffSet < 1 then upperloopoffSet =upperloopoffSet+12 end
			
			if UpTable[upperloopoffSet] then Hide(UpTable[upperloopoffSet] )	end
			
			upperCircOutIndex=upperCircOutIndex%12+1
		
		end 
		Counter=Counter+1
		if Counter== totalLength then 
			Turn(BigLUpCenter,y_axis,math.rad(0),0)
			resetT(UpTable)
			showT(UpTable)
			Hide(OuterLoop14)
			Move(Wall,y_axis,-7,0);Show(Wall);Move(Wall,y_axis,0,3.1415)
		return end
	end
	
	--clean up
	if boolDirection ==true then
		Turn(BigLUpCenter,y_axis,math.rad(0),0)
		resetT(UpTable)
		showT(UpTable)
		Hide(OuterLoop14)
		Move(Wall,y_axis,-7,0);Show(Wall);Move(Wall,y_axis,0,3.1415)
	else
		Turn(BigLUpCenter,y_axis,math.rad(0),0)
		resetT(UpTable)
		hideT(UpTable)
		Hide(OuterLoop14)
		WMove(Wall,y_axis,-7,3.1415);Hide(Wall);
		
	end
	
	
	
end


SecondTowerCenter=OuterLoop30
TowerCenter=NGon085
STowerTable={}
TowerTable={}
TowerTable[1]={NGon090,NGon089,NGon086,Gun3,Mag5,Mag6}
TowerTable[2]={NGon085,NGon086,NGon087}
STowerTable[1]={OuterLoop31}
STowerTable[2]={OuterLoop30}

function 	TowerDeploy(boolReverse) 
	if boolReverse==true then-- up
	
		DeployInOrderTower(boolReverse)
		SignalTable["UpperCircleLoop"]=false
		SignalTable["GoUp"]=false
		SignalTable["OuterCircleLoop"]=false
	else
		
	end
	
end



Seed10=piece"Seed10"
towerDeployTable={
	[1]={pieceA=NGon085,offA={x=0,y=-LengthFeed-23,z=0},pieceList={NGon086,NGon087},	SeedDir={x=0,	y=180,	z=-90}},
	[2]={pieceA=NGon090,offA={x=0,y=-LengthFeed-23,z=0},pieceList={NGon088,NGon089,Gun3,Mag5,Mag6},	SeedDir={x=0,	y=180,	z=-90}},
	[3]={pieceA=OuterLoop30,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[4]={pieceA=OuterLoop31,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}}
	
}

piecesDeployTable={
	[1]={pieceA=OuterLoop25,offA={x=0,y=0,z=LengthFeed+17.5},pieceList={},				SeedDir={x=90,	y=-90,	z=0}},
	[2]={pieceA=OuterLoop29,offA={x=0,y=-LengthFeed-23,z=0},pieceList={Gun4,Mag8,Mag7},	SeedDir={x=0,	y=180,	z=-90}},
	
	[3]={pieceA=OuterLoop26,offA={x=-LengthFeed-17.5,y=0,z=0},pieceList={},				SeedDir={x=90,	y=180,	z=0}},
	[4]={pieceA=OuterLoop28,offA={x=-2,y=-LengthFeed-20,z=0},pieceList={Gun2,Mag4,Mag3},SeedDir={x=0,	y=180,	z=-90}},
	
	[5]={pieceA=OuterLoop56,offA={x=0,y=-23,z=-1*(LengthFeed+17.5)},pieceList={},			SeedDir={x=-180,	y=90,	z=0}},
	[6]={pieceA=OuterLoop27,offA={x=0,y=-LengthFeed-23,z=0},pieceList={Gun1,Mag1,Mag2},	SeedDir={x=0,	y=270,	z=-90}},
	[7]={pieceA=OuterLoop33,offA={x=-LengthFeed-20.5,y=0,z=0},pieceList={InnerOrigin},	SeedDir={x=180,	y=180,	z=0}},
	[8]={pieceA=OuterLoop32,offA={x=-LengthFeed-20.5,y=0,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=0}},
	[9]={pieceA=OuterLoop42,offA={x=-LengthFeed-20.5,y=0,z=0},pieceList={},	SeedDir={x=180,	y=180,	z=0}},
	[10]={pieceA=OuterLoop35,offA={x=-7,y=10,z=LengthFeed/2+5},pieceList={},	SeedDir={x=90,	y=-90,	z=0}},
	[11]={pieceA=OuterLoop34,offA={x=-7,y=10,z=-LengthFeed-5},pieceList={},	SeedDir={x=90,	y=90,	z=0}},
	[12]={pieceA=OuterLoop40,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[13]={pieceA=OuterLoop41,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[14]={pieceA=OuterLoop43,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[15]={pieceA=OuterLoop44,offA={x=0,y=-52,z=-52		},pieceList={},	SeedDir={x=0,	y=90,	z=-45}},
	[16]={pieceA=OuterLoop47,offA={x=0,y=-52,z=-52		},pieceList={},	SeedDir={x=0,	y=90,	z=-45}},
	[17]={pieceA=OuterLoop55,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[18]={pieceA=OuterLoop54,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[19]={pieceA=OuterLoop50,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[20]={pieceA=OuterLoop51,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},		
	[21]={pieceA=OuterLoop45,offA={x=0,y=-52,z=-52			},pieceList={},	SeedDir={x=0,	y=90,	z=-45}},
	[22]={pieceA=OuterLoop46,offA={x=0,y=-52,z=-52			},pieceList={},	SeedDir={x=0,	y=90,	z=-45}},
	[23]={pieceA=OuterLoop48,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[24]={pieceA=OuterLoop49,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[25]={pieceA=OuterLoop53,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[26]={pieceA=OuterLoop52,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[27]={pieceA=OuterLoop36,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},		
	[28]={pieceA=OuterLoop37,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	[29]={pieceA=OuterLoop38,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},		
	[30]={pieceA=OuterLoop39,offA={x=0,y=-LengthFeed-23,z=0},pieceList={},	SeedDir={x=0,	y=180,	z=-90}},
	
	--[1]={pieceA,offA,pieceList,seedDir},
}

function 	DeployInOrderTower(boolReverse) 

if boolReverse==true then
	for i=1,#GunTable,1 do
		Turn(GunTable[i],x_axis,math.rad(-90),0)
	end
	
	
	
	pieceToGo=0
	for i=1,#towerDeployTable, 1 do
		
		pieceToGo=towerDeployTable[i].pieceA
		
		offSet= towerDeployTable[i].offA
		DirVec=towerDeployTable[i].SeedDir
		reset(SeedCenter,0)
		MovePieceToPiece(SeedCenter,pieceToGo,0,offSet,forceUpdate)
		
		Turn(SeedCenter,x_axis,math.rad(DirVec.x),0)
		Turn(SeedCenter,y_axis,math.rad(DirVec.y),0)
		Turn(SeedCenter,z_axis,math.rad(DirVec.z),0)
		
		SeedLoop(1,feed_speed,boolReverse,radialSpeed)
		
		
			Show(pieceToGo)
			if towerDeployTable[i].pieceList then showT(towerDeployTable[i].pieceList) end
		
		
	end
	Sleep(100)
else
	for i=#towerDeployTable,1, -1 do
		
		pieceToGo=towerDeployTable[i].pieceA
		
		offSet= towerDeployTable[i].offA
		DirVec=towerDeployTable[i].SeedDir
		reset(SeedCenter,0)
		MovePieceToPiece(SeedCenter,pieceToGo,0,offSet,forceUpdate)
		Hide(pieceToGo)
		Turn(SeedCenter,x_axis,math.rad(DirVec.x),0)
		Turn(SeedCenter,y_axis,math.rad(DirVec.y),0)
		Turn(SeedCenter,z_axis,math.rad(DirVec.z),0)
		
		SeedLoop(1,feed_speed,boolReverse,radialSpeed)
		
		
			
			if towerDeployTable[i].pieceList then hideT(towerDeployTable[i].pieceList) end
		
	end

end	
end	



function 	DeployInOrder(boolReverse) 
if boolReverse == true then
	for i=1,#GunTable,1 do
		Turn(GunTable[i],x_axis,math.rad(-90),0)
	end
	
	
	pieceToGo=0
	for i=1,#piecesDeployTable, 1 do
		
		pieceToGo=piecesDeployTable[i].pieceA
		
		offSet=piecesDeployTable[i].offA
		DirVec=piecesDeployTable[i].SeedDir
		reset(SeedCenter,0)
		MovePieceToPiece(SeedCenter,pieceToGo,0,offSet,forceUpdate)
		
		Turn(SeedCenter,x_axis,math.rad(DirVec.x),0)
		Turn(SeedCenter,y_axis,math.rad(DirVec.y),0)
		Turn(SeedCenter,z_axis,math.rad(DirVec.z),0)
		SeedLoop(1,feed_speed,boolReverse,radialSpeed)
		
		
			Show(pieceToGo)
			if piecesDeployTable[i].pieceList then showT(piecesDeployTable[i].pieceList) end
		
		
	end
	Sleep(100)
else
	for i=#piecesDeployTable,1, -1 do
		pieceToGo=piecesDeployTable[i].pieceA
		
		offSet=piecesDeployTable[i].offA
		DirVec=piecesDeployTable[i].SeedDir
		reset(SeedCenter,0)
		MovePieceToPiece(SeedCenter,pieceToGo,0,offSet,forceUpdate)
		
		Turn(SeedCenter,x_axis,math.rad(DirVec.x),0)
		Turn(SeedCenter,y_axis,math.rad(DirVec.y),0)
		Turn(SeedCenter,z_axis,math.rad(DirVec.z),0)
		SeedLoop(1,feed_speed,boolReverse,radialSpeed)


				Hide(pieceToGo)
				if piecesDeployTable[i].pieceList then hideT(piecesDeployTable[i].pieceList) end
			
	end
end
	
end
CataRoto={}
CataLow	={}
CataUp	={}
CataHead={}

function reloadCataPult()
	
	hideT(CataRoto	)
	hideT(CataLow	)
	hideT(CataUp	)
	hideT(CataHead	)
	resetT(CataRoto	)
	resetT(CataLow	)
	resetT(CataUp	)
	resetT(CataHead	)
	
	turnT(CataHead,x_axis,31,0,true)
	moveT(CataLow,y_axis,-20,0)
	moveT(CataLow,z_axis,16,0)
	Sleep(1000)
	showT(CataHead)
	showT(CataUp)
	turnT(CataHead,x_axis,-150,0,true)
	moveT(CataLow,y_axis,-33,12)
	moveT(CataLow,y_axis,-12,12)
	moveT(CataLow,z_axis,0,12)
	Sleep(1000)
	turnT(CataHead,x_axis,-235,12,true)
	Sleep(1000)
	
	showT(CataLow)
	moveT(CataLow,y_axis,0,13)
	moveT(CataLow,x_axis,0,13)
	moveT(CataLow,z_axis,0,13)
	turnT(CataHead,x_axis,0,12,true)
	Sleep(3000)
	
end

function 	InnerCityDeploy(boolReverse) 
	if boolReverse==true then
	for k,v in pairs(SignalTable) do
		if k ~= "GateLoop" then
			SignalTable[k]=false
		end
	end
	
	StartThread(reloadCataPult)
	else
	hideT(CataLow)
	
	end
	
	
end

function 	RailGunUnfold(boolReverse) 
	if boolReverse == true then
	WMove(RailGun,y_axis,-110-18,0)
	Show(RailGun)
	WMove(RailGun,y_axis,0,feed_speed)
	Show(Projectile)
	else
	WMove(RailGun,y_axis,-110-18,0)
	Hide(RailGun)
	end
end



function watchForImpact()
	while GG.FiringGateFotressTable[teamid][unitID]==true do
		Sleep(250)
	end
	boolOnTheMove=true
	foldAnimation()	
	Spring.DstroyUnit(unitID,true,false)
end



function script.Activate()
	boolActivateTravelling=true
	return 1
end

function script.Deactivate()
	boolActivateTravelling=false
	return 0
end

turretSpeed=3.141

function Weapon1fire()	
	if boolActivateTravelling==false then return false end
	boolOneShot=false
	makeTableFromString("FiringGateFotressTable["..teamid.."["..unitID.."]]",true)
	StartThread(watchForImpact)
	return true
end

boolUnfoldComplete=false

function Weapon1( Heading ,pitch)	
	--aiming animation: instantly turn the gun towards the enemy
	gunKey,isUserTarget, val= Spring.GetUnitWeaponTarget(unitID,1)	
	px,py,p=0,0,0
	if gunKey== 1 and isUserTarget==true then px,py,pz=Spring.GetUnitPosition(val)
		return boolOneShot == true and boolDeployed == true
	end
	
	if gunKey== 2 and isUserTarget==true then 
		px,py,pz =val[1],val[2],val[3]
		
		return boolOneShot == true and boolDeployed == true
	end
end


genSignal=1
function SigGen()
	genSignal=2*genSignal
	return genSignal
end

function script.FireWeapon(weaponID)
	--Spring.Echo("FireWeapon")
	if WeaponsTable[weaponID] and WeaponsTable[weaponID].firefunc then
		WeaponsTable[weaponID].firefunc()
	end	
end

function genAim(weaponID,heading, pitch)
	Signal(WeaponsTable[weaponID].signal)
	SetSignalMask(WeaponsTable[weaponID].signal)
	WTurn(WeaponsTable[weaponID].aimpiece,y_axis,heading,turretSpeed)
	WTurn(WeaponsTable[weaponID].aimpiece,x_axis,-pitch,turretSpeed)
	return boolDeployed == true
end

function CataAim1(weaponID,heading, pitch)
	Signal(WeaponsTable[weaponID].signal)
	SetSignalMask(WeaponsTable[weaponID].signal)
	WTurn(CataRoto[1],y_axis,heading,turretSpeed)
	WTurn(WeaponsTable[weaponID].aimpiece,x_axis,-pitch,turretSpeed)
	return boolDeployed == true
end

function CataAim2(weaponID,heading, pitch)
	Signal(WeaponsTable[weaponID].signal)
	SetSignalMask(WeaponsTable[weaponID].signal)
	WTurn(CataRoto[2],y_axis,heading,turretSpeed)
	WTurn(WeaponsTable[weaponID].aimpiece,x_axis,-pitch,turretSpeed)
	return boolDeployed == true
end

function genFire(WeaponID)
	
	return true
end

WeaponsTable={}
WeaponsTable[1]={aimpiece=Projectile,emitpiece=Projectile,aimfunc=Weapon1,firefunc=Weapon1fire, signal=SigGen()}
WeaponsTable[2]={aimpiece=CataHead1,emitpiece=CataHead1,aimfunc=CataAim1,firefunc=genFire, signal=SigGen()}
WeaponsTable[3]={aimpiece=CataHead2,emitpiece=CataHead2,aimfunc=CataAim2,firefunc=genFire, signal=SigGen()}
WeaponsTable[4]={aimpiece=Gun1,emitpiece=Gun1,aimfunc= genAim,firefunc=genFire, signal=SigGen()}
WeaponsTable[5]={aimpiece=Gun2,emitpiece=Gun2,aimfunc= genAim,firefunc=genFire, signal=SigGen()}
WeaponsTable[6]={aimpiece=Gun3,emitpiece=Gun3,aimfunc= genAim,firefunc=genFire, signal=SigGen()}
WeaponsTable[7]={aimpiece=Gun4,emitpiece=Gun4,aimfunc= genAim,firefunc=genFire, signal=SigGen()}

enumerator=8
for k,v in pairs(DronePodTable) do
	local Aimpiece=v
	local Emitpiece=v
	WeaponsTable[enumerator]= {aimpiece=Aimpiece,emitpiece=Emitpiece,aimfunc= function() return true end,firefunc=genFire, signal=SigGen()}
	enumerator=enumerator+1
end 


function script.AimFromWeapon1() temp=WeaponsTable[1].aimpiece ; return temp; end
function script.AimFromWeapon2() temp=WeaponsTable[2].aimpiece ; return temp; end
function script.AimFromWeapon3() temp=WeaponsTable[3].aimpiece ; return temp; end
function script.AimFromWeapon4() temp=WeaponsTable[4].aimpiece ; return temp; end
function script.AimFromWeapon5() temp=WeaponsTable[5].aimpiece ; return temp; end
function script.AimFromWeapon6() temp=WeaponsTable[6].aimpiece ; return temp; end
function script.AimFromWeapon7() temp=WeaponsTable[7].aimpiece ; return temp; end
function script.AimFromWeapon8() temp=WeaponsTable[8].aimpiece ; return temp; end
function script.AimFromWeapon9() temp=WeaponsTable[9].aimpiece ; return temp; end
function script.AimFromWeapon10() temp=WeaponsTable[10].aimpiece ; return temp; end
function script.AimFromWeapon11() temp=WeaponsTable[11].aimpiece ; return temp; end
function script.AimFromWeapon12() temp=WeaponsTable[12].aimpiece ; return temp; end

function script.QueryWeapon1() temp=WeaponsTable[1].emitpiece ; return temp; end
function script.QueryWeapon2() temp=WeaponsTable[2].emitpiece ; return temp; end
function script.QueryWeapon3() temp=WeaponsTable[3].emitpiece ; return temp; end
function script.QueryWeapon4() temp=WeaponsTable[4].emitpiece ; return temp; end
function script.QueryWeapon5() temp=WeaponsTable[5].emitpiece ; return temp; end
function script.QueryWeapon6() temp=WeaponsTable[6].emitpiece ; return temp; end
function script.QueryWeapon7() temp=WeaponsTable[7].emitpiece ; return temp; end
function script.QueryWeapon8() temp=WeaponsTable[8].emitpiece ; return temp; end
function script.QueryWeapon9() temp=WeaponsTable[9].emitpiece ; return temp; end
function script.QueryWeapon10() temp=WeaponsTable[10].emitpiece ; return temp; end
function script.QueryWeapon11() temp=WeaponsTable[11].emitpiece ; return temp; end
function script.QueryWeapon12() temp=WeaponsTable[12].emitpiece ; return temp; end


-- function script.AimFromWeapon(weaponID)	
	-- temp=WeaponsTable[weaponID].aimpiece 	
	-- return temp
-- end

-- function script.QueryWeapon(weaponID)
	-- temp=WeaponsTable[weaponID].emitpiece 
	-- return temp	
-- end


function script.AimWeapon(weaponID, heading, pitch)
	if WeaponsTable[weaponID] then
		Signal(WeaponsTable[weaponID].signal)
		SetSignalMask(WeaponsTable[weaponID].signal)
		if WeaponsTable[weaponID].aimfunc then
			return WeaponsTable[weaponID].aimfunc(weaponID,heading,pitch) and boolDeployed==true
		else
			WTurn(WeaponsTable[weaponID].aimpiece,y_axis,heading,turretSpeed)
			WTurn(WeaponsTable[weaponID].aimpiece,x_axis,-pitch,turretSpeed)
			return true and  boolDeployed==true
		end
	else
		return false 
	end
end